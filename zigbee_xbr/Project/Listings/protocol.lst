C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE PROTOCOL
OBJECT MODULE PLACED IN .\Objects\protocol.obj
COMPILER INVOKED BY: d:\cccc2020\TOOL\Keil\C51\BIN\C51.EXE ..\User\protocol.c OPTIMIZE(SIZE) BROWSE DEBUG OBJECTEXTEND P
                    -RINT(.\Listings\protocol.lst) TABS(2) OBJECT(.\Objects\protocol.obj)

line level    source

   1          /**********************************Copyright (c)**********************************
   2          **                       ç‰ˆæƒæ‰€æœ‰ (C), 2015-2020, æ¶‚é¸¦ç§‘æŠ€
   3          **
   4          **                             http://www.tuya.com
   5          **
   6          *********************************************************************************/
   7          /**
   8           * @file    protocol.c
   9           * @author  æ¶‚é¸¦ç»¼åˆåè®®å¼€å‘ç»„
  10           * @version v2.5.5
  11           * @date    2020.6.1
  12           * @brief                
  13           *                       *******éå¸¸é‡è¦ï¼Œä¸€å®šè¦çœ‹å“¦ï¼ï¼ï¼********
  14           *          1. ç”¨æˆ·åœ¨æ­¤æ–‡ä»¶ä¸­å®ç°æ•°æ®ä¸‹å‘/ä¸ŠæŠ¥åŠŸèƒ½
  15           *          2. DPçš„ID/TYPEåŠæ•°æ®å¤„ç†å‡½æ•°éƒ½éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…å®šä¹‰å®ç°
  16           *          3. å½“å¼€å§‹æŸäº›å®å®šä¹‰åéœ€è¦ç”¨æˆ·å®ç°ä»£ç çš„å‡½æ•°å†…éƒ¨æœ‰#erræç¤º,å®Œæˆå‡½æ•
             -°åè¯·åˆ é™¤è¯¥#err
  17           */
  18          
  19          //#include "bluetooth.h"
  20          #include "string.h"
  21          #include <stdio.h>
  22          #include "wifi.h"
  23          #include "HC89S003F4.h"
  24          
  25          extern u8 xdata switchcnt;      //å¤ä½æ¨¡å—ç‚¹å‡»æ¬¡æ•°è®¡æ•°
  26          extern u8 xdata reset_bt_bn;    //å¤ä½æ¨¡å—çš„å…¨å±€å˜é‡
  27          extern u8 xdata SWITCHflag2;   //å¼€å…³ç¯çš„å˜é‡
  28          extern u8 xdata SWITCHfXBR;    //å¼€å…³é›·è¾¾çš„å˜é‡
  29          extern u8 xdata lightvalue;    //ç¯äº®å€¼
  30          extern u8 xdata XRBoffbrightvalue;  //å…³é›·è¾¾åçš„ç¯äº®å€¼
  31          extern ulong xdata TH;          //é›·è¾¾æ„Ÿåº”åå·®é˜ˆå€¼ï¼Œæ•°å€¼è¶Šå¤§ä»£è¡¨è¶Šä¸çµæ•
  32          extern u8 xdata LIGHT_TH;       //æ„Ÿå…‰é˜ˆå€¼
  33          extern u16 xdata DELAY_NUM;     //æ„Ÿåº”å»¶æ—¶ï¼Œå•ä½ä¸ºç§’
  34          extern u8 xdata lowlightDELAY_NUM;      //å…³ç¯å»¶æ—¶ï¼Œå•ä½ä¸ºåˆ†é’Ÿ
  35          extern u8 xdata light_ad;               //é‡‡åˆ°çš„å…‰æ„Ÿçš„ç¬æ—¶å€¼
  36          u8 xdata cdsvalue = 0;              //æ„Ÿå…‰é€‰æ‹©å€¼
  37          ulong xdata sensing_th = 0;     //é›·è¾¾æ„Ÿåº”é˜ˆå€¼ï¼Œæ•°å€¼è¶Šå¤§è¶Šçµæ•
  38          extern  u8 idata Linkage_flag;  //è”åŠ¨çš„å¼€å…³çš„å…¨å±€
  39          extern  u8 idata Light_on_flag; //
  40          
  41          //const char xdata led_bn_on[]={"led on"};
  42          //const char xdata led_bn_off[]={"led off"};
  43          //const char xdata radar_bn_on[]={"radar on"};
  44          //const char xdata radar_bn_off[]={"radar off"};
  45          
  46          unsigned char DPID_SWITCH_LED2count = 0;
  47          unsigned char DPID_SWITCH_XBRcount = 0;
  48          unsigned char DPID_BRIGHT_VALUEcount = 0;
  49          unsigned char DPID_CDScount = 0;
  50          unsigned char DPID_PIR_DELAYcount = 0;
  51          unsigned char DPID_STANDBY_TIMEcount = 0;
  52          unsigned char DPID_SENSE_STRESScount = 0;
  53          
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 2   

  54          extern u16 idata groupaddr[8];
  55          
  56          //extern TYPE_BUFFER_S FlashBuffer;
  57          void send_data(u8 d);
  58          void reset_bt_module(void);
  59          unsigned char PWM3init(unsigned char ab);
  60          void savevar(void);
  61          void Flash_EraseBlock(unsigned int fui_Address);//flashæ‰‡åŒºæ“¦é™¤
  62          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address);//flashå†™å…¥
  63          void Delay_us_1(uint q1);
  64          
  65          void reset_bt_module(void)
  66          {
  67   1        send_data(0x55);//p15ï¼Œé‡ç½®æ¨¡å—
  68   1        send_data(0xAA);
  69   1        send_data(0x00);
  70   1        send_data(0x04);
  71   1        send_data(0x00);
  72   1        send_data(0x00);
  73   1        send_data(0x03);
  74   1      }
  75          
  76          /******************************************************************************
  77                                          ç§»æ¤é¡»çŸ¥:
  78          1:MCUå¿…é¡»åœ¨whileä¸­ç›´æ¥è°ƒç”¨mcu_api.cå†…çš„wifi_uart_service()å‡½æ•°
  79          2:ç¨‹åºæ­£å¸¸åˆå§‹åŒ–å®Œæˆå,å»ºè®®ä¸è¿›è¡Œå…³ä¸²å£ä¸­æ–­,å¦‚å¿…é¡»å…³ä¸­æ–­,å…³ä¸­æ–­æ—¶é—´å¿…é¡»çŸ
             -­,å…³ä¸­æ–­ä¼šå¼•èµ·ä¸²å£æ•°æ®åŒ…ä¸¢å¤±
  80          3:è¯·å‹¿åœ¨ä¸­æ–­/å®šæ—¶å™¨ä¸­æ–­å†…è°ƒç”¨ä¸ŠæŠ¥å‡½æ•°
  81          ******************************************************************************/
  82          
  83          
  84          #ifdef WEATHER_ENABLE
              /**
               * @var    weather_choose
               * @brief  å¤©æ°”æ•°æ®å‚æ•°é€‰æ‹©æ•°ç»„
               * @note   ç”¨æˆ·å¯ä»¥è‡ªå®šä¹‰éœ€è¦çš„å‚æ•°ï¼Œæ³¨é‡Šæˆ–è€…å–æ¶ˆæ³¨é‡Šå³å¯ï¼Œæ³¨æ„æ›´æ”¹
               */
              const char *weather_choose[WEATHER_CHOOSE_CNT] = {
                  "temp",
                  "humidity",
                  "condition",
                  "pm25",
                  /*"pressure",
                  "realFeel",
                  "uvi",
                  "tips",
                  "windDir",
                  "windLevel",
                  "windSpeed",
                  "sunRise",
                  "sunSet",
                  "aqi",
                  "so2 ",
                  "rank",
                  "pm10",
                  "o3",
                  "no2",
                  "co",*/
              };
              #endif
 113          
 114          
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 3   

 115          /******************************************************************************
 116                                        ç¬¬ä¸€æ­¥:åˆå§‹åŒ–
 117          1:åœ¨éœ€è¦ä½¿ç”¨åˆ°wifiç›¸å…³æ–‡ä»¶çš„æ–‡ä»¶ä¸­include "wifi.h"
 118          2:åœ¨MCUåˆå§‹åŒ–ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶ä¸­çš„wifi_protocol_init()å‡½æ•°
 119          3:å°†MCUä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°å¡«å…¥protocol.cæ–‡ä»¶ä¸­uart_transmit_outputå‡½æ•°å†…,å¹¶åˆ é™¤#error
 120          4:åœ¨MCUä¸²å£æ¥æ”¶å‡½æ•°ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„uart_receive_inputå‡½æ•°,å¹¶å°†æ¥æ”¶åˆ°çš„å­—èŠ‚ä
             -½œä¸ºå‚æ•°ä¼ å…¥
 121          5:å•ç‰‡æœºè¿›å…¥whileå¾ªç¯åè°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„wifi_uart_service()å‡½æ•°
 122          ******************************************************************************/
 123          
 124          /******************************************************************************
 125                                  1:dpæ•°æ®ç‚¹åºåˆ—ç±»å‹å¯¹ç…§è¡¨
 126                    **æ­¤ä¸ºè‡ªåŠ¨ç”Ÿæˆä»£ç ,å¦‚åœ¨å¼€å‘å¹³å°æœ‰ç›¸å…³ä¿®æ”¹è¯·é‡æ–°ä¸‹è½½MCU_SDK**         
 127          ******************************************************************************/
 128          const DOWNLOAD_CMD_S xdata download_cmd[] =
 129          {
 130            {DPID_SWITCH_LED, DP_TYPE_BOOL},
 131            {DPID_BRIGHT_VALUE, DP_TYPE_VALUE},
 132            {DPID_CDS, DP_TYPE_ENUM},
 133            {DPID_PIR_DELAY, DP_TYPE_VALUE},
 134            {DPID_SWITCH_XBR, DP_TYPE_BOOL},
 135            {DPID_STANDBY_TIME, DP_TYPE_VALUE},
 136            {DPID_SENSE_STRESS, DP_TYPE_VALUE},
 137            {DPID_SWITCH_LED2, DP_TYPE_BOOL},
 138            {DPID_SWITCH_LINKAGE, DP_TYPE_BOOL},
 139          };
 140          
 141          
 142          
 143          /******************************************************************************
 144                                     2:ä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°
 145          è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°å†…,å¹¶å°†æ¥æ”¶åˆ°çš„æ•°æ®ä½œä¸ºå‚æ•°ä¼ å…¥ä¸²å£å‘é€å‡½æ•°
 146          ******************************************************************************/
 147          
 148          /**
 149           * @brief  ä¸²å£å‘é€æ•°æ®
 150           * @param[in] {value} ä¸²å£è¦å‘é€çš„1å­—èŠ‚æ•°æ®
 151           * @return Null
 152           */
 153          void uart_transmit_output(unsigned char value)
 154          {
 155   1      // #error "è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°,å¹¶åˆ é™¤è¯¥è¡Œ"
 156   1          send_data(value);
 157   1        
 158   1      /*
 159   1          //Example:
 160   1          extern void Uart_PutChar(unsigned char value);
 161   1          Uart_PutChar(value);                                  //ä¸²å£å‘é€å‡½æ•°
 162   1      */
 163   1      }
 164          
 165          /******************************************************************************
 166                                     ç¬¬äºŒæ­¥:å®ç°å…·ä½“ç”¨æˆ·å‡½æ•°
 167          1:APPä¸‹å‘æ•°æ®å¤„ç†
 168          2:æ•°æ®ä¸ŠæŠ¥å¤„ç†
 169          ******************************************************************************/
 170          
 171          /******************************************************************************
 172                                      1:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 173          å½“å‰å‡½æ•°å¤„ç†å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥(åŒ…æ‹¬å¯ä¸‹å‘/å¯ä¸ŠæŠ¥å’Œåªä¸ŠæŠ¥)
 174            éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…æƒ…å†µå®ç°:
 175            1:éœ€è¦å®ç°å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 4   

 176            2:éœ€è¦å®ç°åªä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 177          æ­¤å‡½æ•°ä¸ºMCUå†…éƒ¨å¿…é¡»è°ƒç”¨
 178          ç”¨æˆ·ä¹Ÿå¯è°ƒç”¨æ­¤å‡½æ•°å®ç°å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥
 179          ******************************************************************************/
 180          
 181          //è‡ªåŠ¨åŒ–ç”Ÿæˆæ•°æ®ä¸ŠæŠ¥å‡½æ•°
 182          
 183          /**
 184           * @brief  ç³»ç»Ÿæ‰€æœ‰dpç‚¹ä¿¡æ¯ä¸Šä¼ ,å®ç°APPå’Œmucæ•°æ®åŒæ­¥
 185           * @param  Null
 186           * @return Null
 187           * @note   æ­¤å‡½æ•°SDKå†…éƒ¨éœ€è°ƒç”¨ï¼ŒMCUå¿…é¡»å®ç°è¯¥å‡½æ•°å†…æ•°æ®ä¸ŠæŠ¥åŠŸèƒ½ï¼ŒåŒ…æ‹¬åªä¸ŠæŠ¥å’
             -Œå¯ä¸ŠæŠ¥å¯ä¸‹å‘å‹æ•°æ®
 188           */
 189          void all_data_update(void)
 190          {
 191   1          u8 light;
 192   1          u8 radius;
 193   1        //#error "è¯·åœ¨æ­¤å¤„ç†å¯ä¸‹å‘å¯ä¸ŠæŠ¥æ•°æ®åŠåªä¸ŠæŠ¥æ•°æ®ç¤ºä¾‹,å¤„ç†å®Œæˆååˆ é™¤è¯¥è¡Œ"
 194   1        //æ­¤ä»£ç ä¸ºå¹³å°è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·æŒ‰ç…§å®é™…æ•°æ®ä¿®æ”¹æ¯ä¸ªå¯ä¸‹å‘å¯ä¸ŠæŠ¥å‡½æ•°å’Œåªä¸ŠæŠ¥
             -å‡½æ•°
 195   1        
 196   1          mcu_dp_bool_update(DPID_SWITCH_LED, reset_bt_bn); //å¤ä½æ¨¡å—
 197   1          mcu_dp_bool_update(DPID_SWITCH_LED2, SWITCHflag2); //ç¯çš„å¼€å…³
 198   1          mcu_dp_value_update(DPID_BRIGHT_VALUE, lightvalue); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 199   1      
 200   1        if(LIGHT_TH==255)
 201   1          light=0;
 202   1        else if(LIGHT_TH==200)
 203   1          light=2;
 204   1        else if(LIGHT_TH==40)
 205   1          light=3;    
 206   1        else if(LIGHT_TH==20)
 207   1          light=4;
 208   1        else //if(LIGHT_TH==200)
 209   1          light=5;
 210   1      
 211   1          mcu_dp_enum_update(DPID_CDS, light); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 212   1          mcu_dp_value_update(DPID_PIR_DELAY, DELAY_NUM); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 213   1          mcu_dp_bool_update(DPID_SWITCH_XBR, SWITCHfXBR); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 214   1          mcu_dp_value_update(DPID_STANDBY_TIME, lowlightDELAY_NUM); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 215   1      
 216   1        radius=TH/10000;
 217   1        radius=50-radius;
 218   1      
 219   1          mcu_dp_value_update(DPID_SENSE_STRESS, radius); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 220   1      
 221   1      //    mcu_dp_value_update(DPID_ADDR, 10); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 222   1      //    mcu_dp_value_update(DPID_ADDREND, 11); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 223   1      //    mcu_dp_value_update(DPID_GROUP, 12); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 224   1      
 225   1      
 226   1      //    mcu_dp_string_update(DPID_DEBUG, "1012", 4); //STRINGå‹æ•°æ®ä¸ŠæŠ¥;
 227   1      
 228   1      
 229   1          //mcu_dp_bool_update(DPID_TEST_BN0,å½“å‰æµ‹è¯•å¼€å…³0); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 230   1          //mcu_dp_bool_update(DPID_TEST_BN1,å½“å‰æµ‹è¯•å¼€å…³1); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 231   1          //mcu_dp_bool_update(DPID_TEST_BN2,å½“å‰æµ‹è¯•å¼€å…³2); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 232   1        
 233   1        mcu_dp_bool_update(DPID_SWITCH_LINKAGE,Linkage_flag); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 234   1      
 235   1      
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 5   

 236   1      
 237   1      }
 238          
 239          
 240          /******************************************************************************
 241                                          WARNING!!!    
 242                                      2:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 243          è‡ªåŠ¨åŒ–ä»£ç æ¨¡æ¿å‡½æ•°,å…·ä½“è¯·ç”¨æˆ·è‡ªè¡Œå®ç°æ•°æ®å¤„ç†
 244          ******************************************************************************/
 245          /*****************************************************************************
 246          å‡½æ•°åç§° : dp_download_switch_led_handle
 247          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCH_LEDçš„å¤„ç†å‡½æ•°
 248          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 249                  : length:æ•°æ®é•¿åº¦
 250          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 251          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 252          *****************************************************************************/
 253          static unsigned char dp_download_switch_led_handle(const unsigned char value[], unsigned short length)
 254          {
 255   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 256   1          unsigned char ret;
 257   1          //0:å…³/1:å¼€
 258   1          unsigned char switch_led;
 259   1          
 260   1          switch_led = mcu_get_dp_download_bool(value,length);
 261   1      
 262   1          reset_bt_bn = switch_led;
 263   1        
 264   1          
 265   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 266   1          ret = mcu_dp_bool_update(DPID_SWITCH_LED, reset_bt_bn);
 267   1          if(ret == SUCCESS)
 268   1              return SUCCESS;
 269   1          else
 270   1              return ERROR;
 271   1      }
 272          /*****************************************************************************
 273          å‡½æ•°åç§° : dp_download_bright_value_handle
 274          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_BRIGHT_VALUEçš„å¤„ç†å‡½æ•°
 275          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 276                  : length:æ•°æ®é•¿åº¦
 277          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 278          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 279          *****************************************************************************/
 280          static unsigned char dp_download_bright_value_handle(const unsigned char value[], unsigned short length)
 281          {
 282   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 283   1          unsigned char ret;
 284   1          unsigned long bright_value;
 285   1          unsigned char i;
 286   1          
 287   1          bright_value = mcu_get_dp_download_value(value,length);
 288   1        
 289   1        DPID_BRIGHT_VALUEcount++;
 290   1        if(bright_value==lightvalue)
 291   1        {
 292   2      /*    if(DPID_BRIGHT_VALUEcount<2)
 293   2          {
 294   2            //DPID_BRIGHT_VALUEcount = 0;
 295   2            
 296   2            for(i=0;i<8;i++)
 297   2            {
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 6   

 298   2              if(groupaddr[i] != 0)
 299   2              {
 300   2                mcu_dp_value_mesh_update(DPID_BRIGHT_VALUE,bright_value,groupaddr[i]);
 301   2              }
 302   2            }
 303   2          } */
 304   2        }
 305   1        else
 306   1        {
 307   2          DPID_BRIGHT_VALUEcount=0;
 308   2          for(i=0;i<8;i++)
 309   2          {
 310   3      //      if(groupaddr[i] != 0)
 311   3      //      {
 312   3      //        mcu_dp_value_mesh_update(DPID_BRIGHT_VALUE,bright_value,groupaddr[i]);
 313   3      //      }
 314   3          }
 315   2        } 
 316   1        
 317   1          lightvalue = bright_value;
 318   1      
 319   1        if(SWITCHfXBR==0)
 320   1        {
 321   2          XRBoffbrightvalue = bright_value;
 322   2        }
 323   1        
 324   1        savevar();
 325   1          
 326   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 327   1          ret = mcu_dp_value_update(DPID_BRIGHT_VALUE, lightvalue);
 328   1      
 329   1          if(ret == SUCCESS)
 330   1              return SUCCESS;
 331   1          else
 332   1              return ERROR;
 333   1      }
 334          /*****************************************************************************
 335          å‡½æ•°åç§° : dp_download_cds_handle
 336          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_CDSçš„å¤„ç†å‡½æ•°
 337          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 338                  : length:æ•°æ®é•¿åº¦
 339          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 340          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 341          *****************************************************************************/
 342          static unsigned char dp_download_cds_handle(const unsigned char value[], unsigned short length)
 343          {
 344   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºENUM
 345   1          unsigned char ret;
 346   1          unsigned char cds;
 347   1          unsigned char i;
 348   1          
 349   1          cds = mcu_get_dp_download_enum(value,length);
 350   1        
 351   1        DPID_CDScount++;
 352   1        if(cds==cdsvalue)
 353   1        {
 354   2          if(DPID_CDScount<2)
 355   2          {
 356   3      /*      for(i=0;i<8;i++)
 357   3            {
 358   3              if(groupaddr[i] != 0)
 359   3              {
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 7   

 360   3                mcu_dp_enum_mesh_update(DPID_CDS,cds,groupaddr[i]);
 361   3              }
 362   3            } */
 363   3          }
 364   2          if((cds==5)&&(light_ad!=LIGHT_TH))
 365   2          {
 366   3            DPID_CDScount=0;
 367   3          }
 368   2        }
 369   1        else
 370   1        {
 371   2          DPID_CDScount=0;
 372   2          for(i=0;i<8;i++)
 373   2          {
 374   3      //      if(groupaddr[i] != 0)
 375   3      //      {
 376   3      //        mcu_dp_enum_mesh_update(DPID_CDS,cds,groupaddr[i]);
 377   3      //      }
 378   3          }
 379   2        } 
 380   1        
 381   1          switch(cds) {
 382   2              case 0:   //2000LUS
 383   2            LIGHT_TH=255;//cds*4;
 384   2              break;
 385   2              
 386   2              case 1:   //300LUX
 387   2            LIGHT_TH=255;//cds*4;
 388   2              break;
 389   2              
 390   2              case 2:   //50LUX
 391   2            LIGHT_TH=200;
 392   2              break;
 393   2              
 394   2              case 3: //10LUX
 395   2            LIGHT_TH=40;
 396   2              break;
 397   2              
 398   2              case 4: //5LUX
 399   2            LIGHT_TH=20;
 400   2              break;
 401   2              
 402   2          case 5:
 403   2            LIGHT_TH = light_ad;
 404   2          break;
 405   2              
 406   2              default:
 407   2          
 408   2              break;
 409   2          }
 410   1      
 411   1          cdsvalue = cds;
 412   1      
 413   1          savevar();
 414   1          //sprintf(temp_str, "%3d", LIGHT_TH);
 415   1          //mcu_dp_string_update(DPID_DEBUG, temp_str, strlen(temp_str));
 416   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 417   1          ret = mcu_dp_enum_update(DPID_CDS, cdsvalue);
 418   1          if(ret == SUCCESS)
 419   1              return SUCCESS;
 420   1          else
 421   1              return ERROR;
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 8   

 422   1      }
 423          /*****************************************************************************
 424          å‡½æ•°åç§° : dp_download_pir_delay_handle
 425          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_PIR_DELAYçš„å¤„ç†å‡½æ•°
 426          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 427                  : length:æ•°æ®é•¿åº¦
 428          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 429          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 430          *****************************************************************************/
 431          static unsigned char dp_download_pir_delay_handle(const unsigned char value[], unsigned short length)
 432          {
 433   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 434   1          unsigned char ret;
 435   1          unsigned long pir_delay;
 436   1          unsigned char i;
 437   1          
 438   1          pir_delay = mcu_get_dp_download_value(value,length);
 439   1          /*
 440   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 441   1          */
 442   1        
 443   1        DPID_PIR_DELAYcount++;
 444   1        if(pir_delay==DELAY_NUM)
 445   1        {
 446   2      /*    if(DPID_PIR_DELAYcount<2)
 447   2          {
 448   2            for(i=0;i<8;i++)
 449   2            {
 450   2              if(groupaddr[i] != 0)
 451   2              {
 452   2                mcu_dp_value_mesh_update(DPID_PIR_DELAY,pir_delay,groupaddr[i]);
 453   2              }
 454   2            }
 455   2          } */
 456   2        }
 457   1        else
 458   1        {
 459   2          DPID_PIR_DELAYcount=0;
 460   2          for(i=0;i<8;i++)
 461   2          {
 462   3      //      if(groupaddr[i] != 0)
 463   3      //      {
 464   3      //        mcu_dp_value_mesh_update(DPID_PIR_DELAY,pir_delay,groupaddr[i]);
 465   3      //      }
 466   3          }
 467   2        }
 468   1        
 469   1          DELAY_NUM = pir_delay;
 470   1        savevar();
 471   1          
 472   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 473   1          ret = mcu_dp_value_update(DPID_PIR_DELAY, DELAY_NUM);
 474   1          if(ret == SUCCESS)
 475   1              return SUCCESS;
 476   1          else
 477   1              return ERROR;
 478   1      }
 479          /*****************************************************************************
 480          å‡½æ•°åç§° : dp_download_switch_xbr_handle
 481          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCH_XBRçš„å¤„ç†å‡½æ•°
 482          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 483                  : length:æ•°æ®é•¿åº¦
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 9   

 484          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 485          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 486          *****************************************************************************/
 487          static unsigned char dp_download_switch_xbr_handle(const unsigned char value[], unsigned short length)
 488          {
 489   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 490   1          unsigned char ret;
 491   1          //0:å…³/1:å¼€
 492   1          unsigned char switch_xbr;
 493   1          unsigned char i;
 494   1          
 495   1          switch_xbr = mcu_get_dp_download_bool(value,length);
 496   1        
 497   1        DPID_SWITCH_XBRcount++;
 498   1        if(switch_xbr==SWITCHfXBR)
 499   1        {
 500   2      /*    if(DPID_SWITCH_XBRcount<2)
 501   2          {
 502   2            for(i=0;i<8;i++)
 503   2            {
 504   2              if(groupaddr[i] != 0)
 505   2              {
 506   2                mcu_dp_bool_mesh_update(DPID_SWITCH_XBR,switch_xbr,groupaddr[i]);
 507   2              }
 508   2            }
 509   2          } */
 510   2        }
 511   1        else
 512   1        {
 513   2          DPID_SWITCH_XBRcount=0;
 514   2          for(i=0;i<8;i++)
 515   2          {
 516   3      //      if(groupaddr[i] != 0)
 517   3      //      {
 518   3      //        mcu_dp_bool_mesh_update(DPID_SWITCH_XBR,switch_xbr,groupaddr[i]);
 519   3      //      }
 520   3          }
 521   2        
 522   2        }
 523   1        
 524   1          if(switch_xbr == 0) {
 525   2              //å¼€å…³å…³
 526   2              SWITCHfXBR = 0;
 527   2              //mcu_dp_string_update(DPID_DEBUG, radar_bn_off, strlen(radar_bn_off));
 528   2          }else {
 529   2              //å¼€å…³å¼€
 530   2              SWITCHfXBR = 1;
 531   2              //mcu_dp_string_update(DPID_DEBUG, radar_bn_on, strlen(radar_bn_on));
 532   2          }
 533   1        
 534   1          savevar();
 535   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 536   1          ret = mcu_dp_bool_update(DPID_SWITCH_XBR,SWITCHfXBR);
 537   1          if(ret == SUCCESS)
 538   1              return SUCCESS;
 539   1          else
 540   1              return ERROR;
 541   1      }
 542          /*****************************************************************************
 543          å‡½æ•°åç§° : dp_download_standby_time_handle
 544          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_STANDBY_TIMEçš„å¤„ç†å‡½æ•°
 545          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 10  

 546                  : length:æ•°æ®é•¿åº¦
 547          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 548          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 549          *****************************************************************************/
 550          static unsigned char dp_download_standby_time_handle(const unsigned char value[], unsigned short length)
 551          {
 552   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 553   1          unsigned char ret;
 554   1          unsigned long standby_time;
 555   1          unsigned char i;
 556   1          
 557   1          standby_time = mcu_get_dp_download_value(value,length);
 558   1          /*
 559   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 560   1          
 561   1          */
 562   1        DPID_STANDBY_TIMEcount++;
 563   1        if(standby_time==lowlightDELAY_NUM)
 564   1        {
 565   2      /*    if(DPID_STANDBY_TIMEcount<2)
 566   2          {
 567   2            for(i=0;i<8;i++)
 568   2            {
 569   2              if(groupaddr[i] != 0)
 570   2              {
 571   2                mcu_dp_value_mesh_update(DPID_STANDBY_TIME,standby_time,groupaddr[i]);
 572   2              }
 573   2            }
 574   2          } */
 575   2        }
 576   1        else
 577   1        {
 578   2          DPID_STANDBY_TIMEcount=0;
 579   2          for(i=0;i<8;i++)
 580   2            {
 581   3      //        if(groupaddr[i] != 0)
 582   3      //        {
 583   3      //          mcu_dp_value_mesh_update(DPID_STANDBY_TIME,standby_time,groupaddr[i]);
 584   3      //        }
 585   3            }
 586   2        
 587   2        }
 588   1        
 589   1          lowlightDELAY_NUM=standby_time;
 590   1          
 591   1          savevar();
 592   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 593   1          ret = mcu_dp_value_update(DPID_STANDBY_TIME, lowlightDELAY_NUM);
 594   1          if(ret == SUCCESS)
 595   1              return SUCCESS;
 596   1          else
 597   1              return ERROR;
 598   1      }
 599          /*****************************************************************************
 600          å‡½æ•°åç§° : dp_download_sense_stress_handle
 601          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SENSE_STRESSçš„å¤„ç†å‡½æ•°
 602          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 603                  : length:æ•°æ®é•¿åº¦
 604          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 605          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 606          *****************************************************************************/
 607          static unsigned char dp_download_sense_stress_handle(const unsigned char value[], unsigned short length)
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 11  

 608          {
 609   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 610   1          unsigned char ret;
 611   1          unsigned long sense_stress;
 612   1          unsigned char i;
 613   1          
 614   1          sense_stress = mcu_get_dp_download_value(value,length);
 615   1          /*
 616   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 617   1          
 618   1          */
 619   1        DPID_SENSE_STRESScount++;
 620   1        if(sense_stress==sensing_th)
 621   1        {
 622   2      /*    if(DPID_SENSE_STRESScount<2)
 623   2          {
 624   2            for(i=0;i<8;i++)
 625   2            {
 626   2              if(groupaddr[i] != 0)
 627   2              {
 628   2                mcu_dp_value_mesh_update(DPID_SENSE_STRESS,sense_stress,groupaddr[i]);
 629   2              }
 630   2            }
 631   2          } */
 632   2        }
 633   1        else
 634   1        {
 635   2          DPID_SENSE_STRESScount=0;
 636   2          for(i=0;i<8;i++)
 637   2          {
 638   3      //      if(groupaddr[i] != 0)
 639   3      //      {
 640   3      //        mcu_dp_value_mesh_update(DPID_SENSE_STRESS,sense_stress,groupaddr[i]);
 641   3      //      }
 642   3          }
 643   2        } 
 644   1        
 645   1        sensing_th = sense_stress;
 646   1        TH=(50-sense_stress)*10000;
 647   1          
 648   1        savevar();
 649   1          
 650   1          //sprintf(temp_str, "%6d", TH);
 651   1          //mcu_dp_string_update(DPID_DEBUG, temp_str, strlen(temp_str));    
 652   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 653   1          ret = mcu_dp_value_update(DPID_SENSE_STRESS, sensing_th);
 654   1          if(ret == SUCCESS)
 655   1              return SUCCESS;
 656   1          else
 657   1              return ERROR;
 658   1      }
 659          /*****************************************************************************
 660          å‡½æ•°åç§° : dp_download_switch_led2_handle
 661          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCH_LED2çš„å¤„ç†å‡½æ•°
 662          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 663                  : length:æ•°æ®é•¿åº¦
 664          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 665          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 666          *****************************************************************************/
 667          static unsigned char dp_download_switch_led2_handle(const unsigned char value[], unsigned short length)
 668          {
 669   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 12  

 670   1          unsigned char ret;
 671   1          //0:å…³/1:å¼€
 672   1          unsigned char switch_led2;
 673   1          unsigned char i;
 674   1          
 675   1          switch_led2 = mcu_get_dp_download_bool(value,length);
 676   1      
 677   1          DPID_SWITCH_LED2count++;
 678   1          if(switch_led2==SWITCHflag2)
 679   1          {
 680   2      /*      if(DPID_SWITCH_LED2count<2)
 681   2            {
 682   2              for(i=0;i<8;i++)
 683   2              {
 684   2                if(groupaddr[i] != 0)
 685   2                {
 686   2                  mcu_dp_bool_mesh_update(DPID_SWITCH_LED2,switch_led2,groupaddr[i]);
 687   2                }
 688   2              }
 689   2            } */
 690   2          }
 691   1          else
 692   1          {
 693   2            DPID_SWITCH_LED2count=0;
 694   2            for(i=0;i<8;i++)
 695   2            {
 696   3      //        if(groupaddr[i] != 0)
 697   3      //        {
 698   3      //          mcu_dp_bool_mesh_update(DPID_SWITCH_LED2,switch_led2,groupaddr[i]);
 699   3      //        }
 700   3            }   
 701   2      
 702   2          }
 703   1      
 704   1          if(switch_led2 == 0) {
 705   2              //ç¯å¼€å…³å…³
 706   2              SWITCHflag2=0;
 707   2          }else {
 708   2              //ç¯å¼€å…³å¼€
 709   2              //mcu_dp_string_update(DPID_DEBUG, led_bn_on, strlen(led_bn_on));
 710   2              if(SWITCHfXBR==1)
 711   2          {
 712   3            Light_on_flag=1;
 713   3          }
 714   2              SWITCHflag2=1;
 715   2          }
 716   1        
 717   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 718   1          ret = mcu_dp_bool_update(DPID_SWITCH_LED2, SWITCHflag2);
 719   1          if(ret == SUCCESS)
 720   1              return SUCCESS;
 721   1          else
 722   1              return ERROR;
 723   1      }
 724          /*****************************************************************************
 725          å‡½æ•°åç§° : dp_download_switch_linkage_handle
 726          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCH_LINKAGEçš„å¤„ç†å‡½æ•°
 727          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 728                  : length:æ•°æ®é•¿åº¦
 729          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 730          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 731          *****************************************************************************/
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 13  

 732          static unsigned char dp_download_switch_linkage_handle(const unsigned char value[], unsigned short length)
 733          {
 734   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 735   1          unsigned char ret;
 736   1          //0:å…³/1:å¼€
 737   1          unsigned char switch_Linkage;
 738   1          unsigned char i;
 739   1          switch_Linkage = mcu_get_dp_download_bool(value,length);
 740   1          
 741   1        if(switch_Linkage==Linkage_flag)
 742   1        {
 743   2          //
 744   2        }
 745   1        else
 746   1        {
 747   2          for(i=0;i<8;i++)
 748   2          {
 749   3      //      if(groupaddr[i] != 0)
 750   3      //      {
 751   3      //        mcu_dp_bool_mesh_update(DPID_SWITCH_LINKAGE,switch_Linkage,groupaddr[i]);
 752   3      //      }
 753   3          }
 754   2        }
 755   1          if(switch_Linkage == 0) {
 756   2              //é›·è¾¾å¼€å…³å…³
 757   2              //LIGHT_OFF;
 758   2              //PWM3init(0);
 759   2              Linkage_flag=0;
 760   2          }else {
 761   2              //é›·è¾¾å¼€å…³å¼€
 762   2              //LIGHT_ON;
 763   2              //PWM3init(100);
 764   2              Linkage_flag=1;
 765   2          }
 766   1          
 767   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 768   1          ret = mcu_dp_bool_update(DPID_SWITCH_LINKAGE,switch_Linkage);
 769   1          if(ret == SUCCESS)
 770   1              return SUCCESS;
 771   1          else
 772   1              return ERROR;
 773   1      }
 774          
 775          
 776          
 777          
 778          /******************************************************************************
 779                                          WARNING!!!                     
 780          æ­¤éƒ¨åˆ†å‡½æ•°ç”¨æˆ·è¯·å‹¿ä¿®æ”¹!!
 781          ******************************************************************************/
 782          
 783          /**
 784           * @brief  dpä¸‹å‘å¤„ç†å‡½æ•°
 785           * @param[in] {dpid} dpid åºå·
 786           * @param[in] {value} dpæ•°æ®ç¼“å†²åŒºåœ°å€
 787           * @param[in] {length} dpæ•°æ®é•¿åº¦
 788           * @return dpå¤„ç†ç»“æœ
 789           * -           0(ERROR): å¤±è´¥
 790           * -           1(SUCCESS): æˆåŠŸ
 791           * @note   è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
 792           */
 793          unsigned char dp_download_handle(unsigned char dpid,const unsigned char value[], unsigned short length)
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 14  

 794          {
 795   1          /*********************************
 796   1          å½“å‰å‡½æ•°å¤„ç†å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®è°ƒç”¨                    
 797   1          å…·ä½“å‡½æ•°å†…éœ€è¦å®ç°ä¸‹å‘æ•°æ®å¤„ç†
 798   1          å®Œæˆç”¨éœ€è¦å°†å¤„ç†ç»“æœåé¦ˆè‡³APPç«¯,å¦åˆ™APPä¼šè®¤ä¸ºä¸‹å‘å¤±è´¥
 799   1          ***********************************/
 800   1          unsigned char ret;
 801   1          switch(dpid) {
 802   2              case DPID_SWITCH_LED:
 803   2                  //å¼€å…³å¤„ç†å‡½æ•°
 804   2                  ret = dp_download_switch_led_handle(value,length);
 805   2            if(ret==1)
 806   2            {
 807   3              switchcnt ++;
 808   3              if(switchcnt>=5)
 809   3              {
 810   4                switchcnt = 0;
 811   4                          reset_bt_module();
 812   4              }
 813   3            }
 814   2              break;
 815   2              case DPID_BRIGHT_VALUE:
 816   2                  //äº®åº¦å€¼å¤„ç†å‡½æ•°
 817   2                  ret = dp_download_bright_value_handle(value,length);
 818   2                  switchcnt = 0;
 819   2              break;
 820   2              case DPID_CDS:
 821   2                  //å…‰æ•å‚æ•°å¤„ç†å‡½æ•°
 822   2                  ret = dp_download_cds_handle(value,length);
 823   2                  switchcnt = 0;
 824   2              break;
 825   2              case DPID_PIR_DELAY:
 826   2                  //æ„Ÿåº”å»¶æ—¶å¤„ç†å‡½æ•°
 827   2                  ret = dp_download_pir_delay_handle(value,length);
 828   2                  switchcnt = 0;
 829   2              break;
 830   2              case DPID_SWITCH_XBR:
 831   2                  //æ„Ÿåº”å¼€å…³å¤„ç†å‡½æ•°
 832   2                  ret = dp_download_switch_xbr_handle(value,length);
 833   2                  switchcnt = 0;
 834   2              break;
 835   2              case DPID_STANDBY_TIME:
 836   2                  //ä¼´äº®å»¶æ—¶å¤„ç†å‡½æ•°
 837   2                  ret = dp_download_standby_time_handle(value,length);
 838   2                  switchcnt = 0;
 839   2              break;
 840   2              case DPID_SENSE_STRESS:
 841   2                  //æ„Ÿåº”å¼ºåº¦å¤„ç†å‡½æ•°
 842   2                  ret = dp_download_sense_stress_handle(value,length);
 843   2                  switchcnt = 0;
 844   2              break;
 845   2              case DPID_SWITCH_LED2:
 846   2                  //ç¯å¼€å…³å¤„ç†å‡½æ•°
 847   2                  ret = dp_download_switch_led2_handle(value,length);
 848   2                  switchcnt = 0;
 849   2              break;
 850   2              case DPID_SWITCH_LINKAGE:
 851   2                  //è”åŠ¨ å¤„ç†å‡½æ•°
 852   2                  ret = dp_download_switch_linkage_handle(value,length);
 853   2                  switchcnt = 0;
 854   2              break;
 855   2      
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 15  

 856   2        default:
 857   2              switchcnt = 0;
 858   2          break;
 859   2        }
 860   1        return ret;
 861   1      }
 862          
 863          /**
 864           * @brief  è·å–æ‰€æœ‰dpå‘½ä»¤æ€»å’Œ
 865           * @param[in] Null
 866           * @return ä¸‹å‘å‘½ä»¤æ€»å’Œ
 867           * @note   è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
 868           */
 869          unsigned char get_download_cmd_total(void)
 870          {
 871   1          return(sizeof(download_cmd) / sizeof(download_cmd[0]));
 872   1      }
 873          
 874          
 875          /******************************************************************************
 876                                          WARNING!!!                     
 877          æ­¤ä»£ç ä¸ºSDKå†…éƒ¨è°ƒç”¨,è¯·æŒ‰ç…§å®é™…dpæ•°æ®å®ç°å‡½æ•°å†…éƒ¨æ•°æ®
 878          ******************************************************************************/
 879          
 880          #ifdef SUPPORT_MCU_FIRM_UPDATE
              /**
               * @brief  å‡çº§åŒ…å¤§å°é€‰æ‹©
               * @param[in] {package_sz} å‡çº§åŒ…å¤§å°
               * @ref           0x00: 256byte (é»˜è®¤)
               * @ref           0x01: 512byte
               * @ref           0x02: 1024byte
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void upgrade_package_choose(unsigned char package_sz)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è¯·è‡ªè¡Œå®ç°å‡çº§åŒ…å¤§å°é€‰æ‹©ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned short send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, package_sz);
                  wifi_uart_write_frame(UPDATE_START_CMD, MCU_TX_VER, send_len);
              }
              
              /**
               * @brief  MCUè¿›å…¥å›ºä»¶å‡çº§æ¨¡å¼
               * @param[in] {value} å›ºä»¶ç¼“å†²åŒº
               * @param[in] {position} å½“å‰æ•°æ®åŒ…åœ¨äºå›ºä»¶ä½ç½®
               * @param[in] {length} å½“å‰å›ºä»¶åŒ…é•¿åº¦(å›ºä»¶åŒ…é•¿åº¦ä¸º0æ—¶,è¡¨ç¤ºå›ºä»¶åŒ…å‘é€å®Œæˆ)
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              unsigned char mcu_firm_update_handle(const unsigned char value[],unsigned long position,unsigned short len
             -gth)
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆMCUå›ºä»¶å‡çº§ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(length == 0) {
                      //å›ºä»¶æ•°æ®å‘é€å®Œæˆ
                    
                  }else {
                      //å›ºä»¶æ•°æ®å¤„ç†
                    
                  }
                  
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 16  

                  return SUCCESS;
              }
              #endif
 920          
 921          #ifdef SUPPORT_GREEN_TIME
              /**
               * @brief  è·å–åˆ°çš„æ ¼æ—æ—¶é—´
               * @param[in] {time} è·å–åˆ°çš„æ ¼æ—æ—¶é—´æ•°æ®
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_get_greentime(unsigned char time[])
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆç›¸å…³ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  time[0] ä¸ºæ˜¯å¦è·å–æ—¶é—´æˆåŠŸæ ‡å¿—ï¼Œä¸º 0 è¡¨ç¤ºå¤±è´¥ï¼Œä¸º 1è¡¨ç¤ºæˆåŠŸ
                  time[1] ä¸ºå¹´ä»½ï¼Œ0x00 è¡¨ç¤º 2000 å¹´
                  time[2] ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
                  time[3] ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
                  time[4] ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
                  time[5] ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  time[6] ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  */
                  if(time[0] == 1) {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„æ ¼æ—æ•°æ®
                      
                  }else {
                      //è·å–æ ¼æ—æ—¶é—´å‡ºé”™,æœ‰å¯èƒ½æ˜¯å½“å‰wifiæ¨¡å—æœªè”ç½‘
                  }
              }
              #endif
 948          
 949          #ifdef SUPPORT_MCU_RTC_CHECK
              /**
               * @brief  MCUæ ¡å¯¹æœ¬åœ°RTCæ—¶é’Ÿ
               * @param[in] {time} è·å–åˆ°çš„æ ¼æ—æ—¶é—´æ•°æ®
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_write_rtctime(unsigned char time[])
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆRTCæ—¶é’Ÿå†™å…¥ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  Time[0] ä¸ºæ˜¯å¦è·å–æ—¶é—´æˆåŠŸæ ‡å¿—ï¼Œä¸º 0 è¡¨ç¤ºå¤±è´¥ï¼Œä¸º 1è¡¨ç¤ºæˆåŠŸ
                  Time[1] ä¸ºå¹´ä»½ï¼Œ0x00 è¡¨ç¤º 2000 å¹´
                  Time[2] ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
                  Time[3] ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
                  Time[4] ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
                  Time[5] ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  Time[6] ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  Time[7] ä¸ºæ˜ŸæœŸï¼Œä» 1 å¼€å§‹åˆ° 7 ç»“æŸï¼Œ1ä»£è¡¨æ˜ŸæœŸä¸€
                 */
                  if(time[0] == 1) {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„æœ¬åœ°æ—¶é’Ÿæ•°æ®
                   
                  }else {
                      //è·å–æœ¬åœ°æ—¶é’Ÿæ•°æ®å‡ºé”™,æœ‰å¯èƒ½æ˜¯å½“å‰wifiæ¨¡å—æœªè”ç½‘
                  }
              }
              #endif
 977          
 978          #ifdef WIFI_TEST_ENABLE
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 17  

 979          /**
 980           * @brief  wifiåŠŸèƒ½æµ‹è¯•åé¦ˆ
 981           * @param[in] {result} wifiåŠŸèƒ½æµ‹è¯•ç»“æœ
 982           * @ref       0: å¤±è´¥
 983           * @ref       1: æˆåŠŸ
 984           * @param[in] {rssi} æµ‹è¯•æˆåŠŸè¡¨ç¤ºwifiä¿¡å·å¼ºåº¦/æµ‹è¯•å¤±è´¥è¡¨ç¤ºé”™è¯¯ç±»å‹
 985           * @return Null
 986           * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
 987           */
 988          void wifi_test_result(unsigned char result,unsigned char rssi)
 989          {
 990   1          //#error "è¯·è‡ªè¡Œå®ç°wifiåŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
 991   1          if(result == 0) {
 992   2              //æµ‹è¯•å¤±è´¥
 993   2              if(rssi == 0x00) {
 994   3                  //æœªæ‰«æåˆ°åç§°ä¸ºtuya_mdev_testè·¯ç”±å™¨,è¯·æ£€æŸ¥
 995   3              }else if(rssi == 0x01) {
 996   3                  //æ¨¡å—æœªæˆæƒ
 997   3              }
 998   2          }else {
 999   2              //æµ‹è¯•æˆåŠŸ
1000   2              //rssiä¸ºä¿¡å·å¼ºåº¦(0-100, 0ä¿¡å·æœ€å·®ï¼Œ100ä¿¡å·æœ€å¼º)
1001   2          }
1002   1      }
1003          #endif
1004          
1005          #ifdef WEATHER_ENABLE
              /**
              * @brief  mcuæ‰“å¼€å¤©æ°”æœåŠ¡
               * @param  Null
               * @return Null
               */
              void mcu_open_weather(void)
              {
                  int i = 0;
                  char buffer[13] = {0};
                  unsigned char weather_len = 0;
                  unsigned short send_len = 0;
                  
                  weather_len = sizeof(weather_choose) / sizeof(weather_choose[0]);
                    
                  for(i=0;i<weather_len;i++) {
                      buffer[0] = sprintf(buffer+1,"w.%s",weather_choose[i]);
                      send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  }
                  
                  #error "è¯·æ ¹æ®æç¤ºï¼Œè‡ªè¡Œå®Œå–„æ‰“å¼€å¤©æ°”æœåŠ¡ä»£ç ï¼Œå®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  /*
                  //å½“è·å–çš„å‚æ•°æœ‰å’Œæ—¶é—´æœ‰å…³çš„å‚æ•°æ—¶(å¦‚:æ—¥å‡ºæ—¥è½)ï¼Œéœ€è¦æ­é…t.unixæˆ–è€…t.local
             -ä½¿ç”¨ï¼Œéœ€è¦è·å–çš„å‚æ•°æ•°æ®æ˜¯æŒ‰ç…§æ ¼æ—æ—¶é—´è¿˜æ˜¯æœ¬åœ°æ—¶é—´
                  buffer[0] = sprintf(buffer+1,"t.unix"); //æ ¼æ—æ—¶é—´   æˆ–ä½¿ç”¨  buffer[0] = sprintf(buffer+1,"t.lo
             -cal"); //æœ¬åœ°æ—¶é—´
                  send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  */
                  
                  buffer[0] = sprintf(buffer+1,"w.date.%d",WEATHER_FORECAST_DAYS_NUM);
                  send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  
                  wifi_uart_write_frame(WEATHER_OPEN_CMD, MCU_TX_VER, send_len);
              }
              
              /**
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 18  

               * @brief  æ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›ç”¨æˆ·è‡ªå¤„ç†å‡½æ•°
               * @param[in] {res} æ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›ç»“æœ
               * @ref       0: å¤±è´¥
               * @ref       1: æˆåŠŸ
               * @param[in] {err} é”™è¯¯ç 
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void weather_open_return_handle(unsigned char res, unsigned char err)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆæ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›æ•°æ®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char err_num = 0;
                  
                  if(res == 1) {
                      //æ‰“å¼€å¤©æ°”è¿”å›æˆåŠŸ
                  }else if(res == 0) {
                      //æ‰“å¼€å¤©æ°”è¿”å›å¤±è´¥
                      //è·å–é”™è¯¯ç 
                      err_num = err; 
                  }
              }
              
              /**
               * @brief  å¤©æ°”æ•°æ®ç”¨æˆ·è‡ªå¤„ç†å‡½æ•°
               * @param[in] {name} å‚æ•°å
               * @param[in] {type} å‚æ•°ç±»å‹
               * @ref       0: int å‹
               * @ref       1: string å‹
               * @param[in] {data} å‚æ•°å€¼çš„åœ°å€
               * @param[in] {day} å“ªä¸€å¤©çš„å¤©æ°”  0:è¡¨ç¤ºå½“å¤© å–å€¼èŒƒå›´: 0~6
               * @ref       0: ä»Šå¤©
               * @ref       1: æ˜å¤©
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void weather_data_user_handle(char *name, unsigned char type, const unsigned char *data, char day)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„å¤©æ°”æ•°æ®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  int value_int;
                  char value_string[50];//ç”±äºæœ‰çš„å‚æ•°å†…å®¹è¾ƒå¤šï¼Œè¿™é‡Œé»˜è®¤ä¸º50ã€‚æ‚¨å¯ä»¥æ ¹æ®å®šä¹‰çš„å
             -‚æ•°ï¼Œå¯ä»¥é€‚å½“å‡å°‘è¯¥å€¼
                  
                  my_memset(value_string, '\0', 50);
                  
                  //é¦–å…ˆè·å–æ•°æ®ç±»å‹
                  if(type == 0) { //å‚æ•°æ˜¯INTå‹
                      value_int = data[0] << 24 | data[1] << 16 | data[2] << 8 | data[3];
                  }else if(type == 1) {
                      my_strcpy(value_string, data);
                  }
                  
                  //æ³¨æ„è¦æ ¹æ®æ‰€é€‰å‚æ•°ç±»å‹æ¥è·å¾—å‚æ•°å€¼ï¼ï¼ï¼
                  if(my_strcmp(name, "temp") == 0) {
                      printf("day:%d temp value is:%d\r\n", day, value_int);          //int å‹
                  }else if(my_strcmp(name, "humidity") == 0) {
                      printf("day:%d humidity value is:%d\r\n", day, value_int);      //int å‹
                  }else if(my_strcmp(name, "pm25") == 0) {
                      printf("day:%d pm25 value is:%d\r\n", day, value_int);          //int å‹
                  }else if(my_strcmp(name, "condition") == 0) {
                      printf("day:%d condition value is:%s\r\n", day, value_string);  //string å‹
                  }
              }
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 19  

              #endif
1101          
1102          #ifdef MCU_DP_UPLOAD_SYN
              /**
               * @brief  çŠ¶æ€åŒæ­¥ä¸ŠæŠ¥ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0: å¤±è´¥
               * @ref       1: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_upload_syn_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆçŠ¶æ€åŒæ­¥ä¸ŠæŠ¥ç»“æœä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                    
                  if(result == 0) {
                      //åŒæ­¥ä¸ŠæŠ¥å‡ºé”™
                  }else {
                      //åŒæ­¥ä¸ŠæŠ¥æˆåŠŸ
                  }
              }
              #endif
1122          
1123          #ifdef GET_WIFI_STATUS_ENABLE
              /**
               * @brief  è·å– WIFI çŠ¶æ€ç»“æœ
               * @param[in] {result} æŒ‡ç¤º WIFI å·¥ä½œçŠ¶æ€
               * @ref       0x00: wifiçŠ¶æ€ 1 smartconfig é…ç½®çŠ¶æ€
               * @ref       0x01: wifiçŠ¶æ€ 2 AP é…ç½®çŠ¶æ€
               * @ref       0x02: wifiçŠ¶æ€ 3 WIFI å·²é…ç½®ä½†æœªè¿ä¸Šè·¯ç”±å™¨
               * @ref       0x03: wifiçŠ¶æ€ 4 WIFI å·²é…ç½®ä¸”è¿ä¸Šè·¯ç”±å™¨
               * @ref       0x04: wifiçŠ¶æ€ 5 å·²è¿ä¸Šè·¯ç”±å™¨ä¸”è¿æ¥åˆ°äº‘ç«¯
               * @ref       0x05: wifiçŠ¶æ€ 6 WIFI è®¾å¤‡å¤„äºä½åŠŸè€—æ¨¡å¼
               * @ref       0x06: wifiçŠ¶æ€ 7 WIFI è®¾å¤‡å¤„äºsmartconfig&APé…ç½®çŠ¶æ€
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_wifi_status(unsigned char result)
              {
                #error "è¯·è‡ªè¡Œå®Œæˆè·å– WIFI çŠ¶æ€ç»“æœä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
               
                  switch(result) {
                      case 0:
                          //wifiå·¥ä½œçŠ¶æ€1
                      break;
                  
                      case 1:
                          //wifiå·¥ä½œçŠ¶æ€2
                      break;
                      
                      case 2:
                          //wifiå·¥ä½œçŠ¶æ€3
                      break;
                      
                      case 3:
                          //wifiå·¥ä½œçŠ¶æ€4
                      break;
                      
                      case 4:
                          //wifiå·¥ä½œçŠ¶æ€5
                      break;
                      
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 20  

                      case 5:
                          //wifiå·¥ä½œçŠ¶æ€6
                      break;
                    
                      case 6:
                          //wifiå·¥ä½œçŠ¶æ€7
                      break;
                      
                      default:break;
                  }
              }
              #endif
1174          
1175          #ifdef WIFI_STREAM_ENABLE
              /**
               * @brief  æµæœåŠ¡å‘é€ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0x00: æˆåŠŸ
               * @ref       0x01: æµæœåŠ¡åŠŸèƒ½æœªå¼€å¯
               * @ref       0x02: æµæœåŠ¡å™¨æœªè¿æ¥æˆåŠŸ
               * @ref       0x03: æ•°æ®æ¨é€è¶…æ—¶
               * @ref       0x04: ä¼ è¾“çš„æ•°æ®é•¿åº¦é”™è¯¯
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void stream_trans_send_result(unsigned char result)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„æµæœåŠ¡å‘é€ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥
             -è¡Œ"
                  switch(result) {
                      case 0x00:
                          //æˆåŠŸ
                      break;
                      
                      case 0x01:
                          //æµæœåŠ¡åŠŸèƒ½æœªå¼€å¯
                      break;
                      
                      case 0x02:
                          //æµæœåŠ¡å™¨æœªè¿æ¥æˆåŠŸ
                      break;
                      
                      case 0x03:
                          //æ•°æ®æ¨é€è¶…æ—¶
                      break;
                      
                      case 0x04:
                          //ä¼ è¾“çš„æ•°æ®é•¿åº¦é”™è¯¯
                      break;
                      
                      default:break;
                  }
              }
              
              /**
               * @brief  å¤šåœ°å›¾æµæœåŠ¡å‘é€ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0x00: æˆåŠŸ
               * @ref       0x01: å¤±è´¥
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 21  

              void maps_stream_trans_send_result(unsigned char result)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„å¤šåœ°å›¾æµæœåŠ¡å‘é€ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·
             -åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0x00:
                          //æˆåŠŸ
                      break;
                      
                      case 0x01:
                          //å¤±è´¥
                      break;
                      
                      default:break;
                  }
              }
              #endif
1239          
1240          #ifdef WIFI_CONNECT_TEST_ENABLE
              /**
               * @brief  è·¯ç”±ä¿¡æ¯æ¥æ”¶ç»“æœé€šçŸ¥
               * @param[in] {result} æ¨¡å—æ˜¯å¦æˆåŠŸæ¥æ”¶åˆ°æ­£ç¡®çš„è·¯ç”±ä¿¡æ¯
               * @ref       0x00: å¤±è´¥
               * @ref       0x01: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void wifi_connect_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°wifiåŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0) {
                      //è·¯ç”±ä¿¡æ¯æ¥æ”¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‘å‡ºçš„è·¯ç”±ä¿¡æ¯åŒ…æ˜¯å¦æ˜¯å®Œæ•´çš„JSONæ•°æ®åŒ…
                  }else {
                      //è·¯ç”±ä¿¡æ¯æ¥æ”¶æˆåŠŸï¼Œäº§æµ‹ç»“æœè¯·æ³¨æ„WIFI_STATE_CMDæŒ‡ä»¤çš„wifiå·¥ä½œçŠ¶æ€
                  }
              }
              #endif
1259          
1260          #ifdef GET_MODULE_MAC_ENABLE
              /**
               * @brief  è·å–æ¨¡å—macç»“æœ
               * @param[in] {mac} æ¨¡å— MAC æ•°æ®
               * @ref       mac[0]: ä¸ºæ˜¯å¦è·å–macæˆåŠŸæ ‡å¿—ï¼Œ0x00 è¡¨ç¤ºæˆåŠŸï¼Œ0x01 è¡¨ç¤ºå¤±è´¥
               * @ref       mac[1]~mac[6]: å½“è·å– MACåœ°å€æ ‡å¿—ä½å¦‚æœmac[0]ä¸ºæˆåŠŸï¼Œåˆ™è¡¨ç¤ºæ¨¡å—æœ‰æ•ˆçš„M
             -ACåœ°å€
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_get_mac(unsigned char mac[])
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆmacè·å–ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  mac[0]ä¸ºæ˜¯å¦è·å–macæˆåŠŸæ ‡å¿—ï¼Œ0x00 è¡¨ç¤ºæˆåŠŸï¼Œä¸º0x01è¡¨ç¤ºå¤±è´¥
                  mac[1]~mac[6]:å½“è·å– MACåœ°å€æ ‡å¿—ä½å¦‚æœmac[0]ä¸ºæˆåŠŸï¼Œåˆ™è¡¨ç¤ºæ¨¡å—æœ‰æ•ˆçš„MACåœ°å€
                 */
                 
                  if(mac[0] == 1) {
                      //è·å–macå‡ºé”™
                  }else {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„macåœ°å€
                  }
              }
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 22  

              #endif
1284          
1285          #ifdef GET_IR_STATUS_ENABLE
              /**
               * @brief  è·å–çº¢å¤–çŠ¶æ€ç»“æœ
               * @param[in] {result} æŒ‡ç¤ºçº¢å¤–çŠ¶æ€
               * @ref       0x00: çº¢å¤–çŠ¶æ€ 1 æ­£åœ¨å‘é€çº¢å¤–ç 
               * @ref       0x01: çº¢å¤–çŠ¶æ€ 2 å‘é€çº¢å¤–ç ç»“æŸ
               * @ref       0x02: çº¢å¤–çŠ¶æ€ 3 çº¢å¤–å­¦ä¹ å¼€å§‹
               * @ref       0x03: çº¢å¤–çŠ¶æ€ 4 çº¢å¤–å­¦ä¹ ç»“æŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_ir_status(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆçº¢å¤–çŠ¶æ€ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0:
                          //çº¢å¤–çŠ¶æ€ 1
                      break;
                    
                      case 1:
                          //çº¢å¤–çŠ¶æ€ 2
                      break;
                        
                      case 2:
                          //çº¢å¤–çŠ¶æ€ 3
                      break;
                        
                      case 3:
                          //çº¢å¤–çŠ¶æ€ 4
                      break;
                        
                      default:break;
                  }
                  
                  wifi_uart_write_frame(GET_IR_STATUS_CMD, MCU_TX_VER, 0);
              }
              #endif
1322          
1323          #ifdef IR_TX_RX_TEST_ENABLE
              /**
               * @brief  çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹ç»“æœé€šçŸ¥
               * @param[in] {result} æ¨¡å—æ˜¯å¦æˆåŠŸæ¥æ”¶åˆ°æ­£ç¡®çš„ä¿¡æ¯
               * @ref       0x00: å¤±è´¥
               * @ref       0x01: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void ir_tx_rx_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹åŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡
             -Œ"
                  if(result == 0) {
                      //çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹æˆåŠŸ
                  }else {
                      //çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‘å‡ºçš„æ•°æ®åŒ…
                  }
              }
              #endif
1342          
1343          #ifdef FILE_DOWNLOAD_ENABLE
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 23  

              /**
               * @brief  æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°é€‰æ‹©
               * @param[in] {package_sz} æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°
               * @ref       0x00: 256 byte (é»˜è®¤)
               * @ref       0x01: 512 byte
               * @ref       0x02: 1024 byte
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void file_download_package_choose(unsigned char package_sz)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è¯·è‡ªè¡Œå®ç°æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°é€‰æ‹©ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned short send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, package_sz);
                  wifi_uart_write_frame(FILE_DOWNLOAD_START_CMD, MCU_TX_VER, send_len);
              }
              
              /**
               * @brief  æ–‡ä»¶åŒ…ä¸‹è½½æ¨¡å¼
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {position} å½“å‰æ•°æ®åŒ…åœ¨äºæ–‡ä»¶ä½ç½®
               * @param[in] {length} å½“å‰æ–‡ä»¶åŒ…é•¿åº¦(é•¿åº¦ä¸º0æ—¶,è¡¨ç¤ºæ–‡ä»¶åŒ…å‘é€å®Œæˆ)
               * @return æ•°æ®å¤„ç†ç»“æœ
               * -           0(ERROR): å¤±è´¥
               * -           1(SUCCESS): æˆåŠŸ
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              unsigned char file_download_handle(const unsigned char value[],unsigned long position,unsigned short lengt
             -h)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆæ–‡ä»¶åŒ…ä¸‹è½½ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(length == 0) {
                      //æ–‡ä»¶åŒ…æ•°æ®å‘é€å®Œæˆ
                      
                  }else {
                      //æ–‡ä»¶åŒ…æ•°æ®å¤„ç†
                    
                  }
                  
                  return SUCCESS;
              }
              #endif
1385          
1386          #ifdef MODULE_EXPANDING_SERVICE_ENABLE
              /**
               * @brief  æ‰“å¼€æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥ç»“æœ
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void open_module_time_serve_result(const unsigned char value[], unsigned short length)
              {
                  #error "è¯·è‡ªè¡Œå®ç°æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥ç»“æœä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char sub_cmd = value[0];
                  
                  switch(sub_cmd) {
                      case 0x01: { //å­å‘½ä»¤  æ‰“å¼€æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 24  

                          
                          if(value[1] == 0) {
                              //æœåŠ¡å¼€å¯æˆåŠŸ
                          }else {
                              //æœåŠ¡å¼€å¯å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x02: {  //å­å‘½ä»¤  æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥
                          if(0x09 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          unsigned char time_type = value[1]; //0x00:æ ¼æ—æ—¶é—´  0x01:æœ¬åœ°æ—¶é—´
                          unsigned char time_data[7];
                          
                          my_memcpy(time_data, value + 2, length - 2);
                          /*
                          Data[0]ä¸ºå¹´ä»½, 0x00è¡¨ç¤º2000å¹´
                          Data[1]ä¸ºæœˆä»½ï¼Œä»1å¼€å§‹åˆ°12ç»“æŸ
                          Data[2]ä¸ºæ—¥æœŸï¼Œä»1å¼€å§‹åˆ°31ç»“æŸ
                          Data[3]ä¸ºæ—¶é’Ÿï¼Œä»0å¼€å§‹åˆ°23ç»“æŸ
                          Data[4]ä¸ºåˆ†é’Ÿï¼Œä»0å¼€å§‹åˆ°59ç»“æŸ
                          Data[5]ä¸ºç§’é’Ÿï¼Œä»0å¼€å§‹åˆ°15ç»“æŸ
                          Data[6]ä¸ºæ˜ŸæœŸï¼Œä»1å¼€å§‹åˆ°7ç»“æŸï¼Œ1ä»£è¡¨æ˜ŸæœŸä¸€
                          */
                          
                          //åœ¨æ­¤å¤„æ·»åŠ æ—¶é—´æ•°æ®å¤„ç†ä»£ç ï¼Œtime_typeä¸ºæ—¶é—´ç±»å‹
                          
                          unsigned short send_len = 0;
                          send_len = set_wifi_uart_byte(send_len,sub_cmd);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
                      
                      case 0x03: {  //å­å‘½ä»¤  ä¸»åŠ¨è¯·æ±‚å¤©æ°”æœåŠ¡æ•°æ®
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x04: {  //å­å‘½ä»¤  æ‰“å¼€æ¨¡å—é‡ç½®çŠ¶æ€é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 25  

                      }
                      break;
                      
                      case 0x05: {  //å­å‘½ä»¤  æ¨¡å—é‡ç½®çŠ¶æ€é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          switch(value[1]) {
                              case 0x00:
                                  //æ¨¡å—æœ¬åœ°é‡ç½®
                                  
                              break;
                              case 0x01:
                                  //APPè¿œç¨‹é‡ç½®
                                  
                              break;
                              case 0x02:
                                  //APPæ¢å¤å‡ºå‚é‡ç½®
                                  
                              break;
                              default:break;
                          }
                          
                          unsigned short send_len = 0;
                          send_len = set_wifi_uart_byte(send_len, sub_cmd);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
                      
                      default:break;
                  }
              }
              #endif
1502          
1503          #ifdef BLE_RELATED_FUNCTION_ENABLE
              /**
               * @brief  è“ç‰™åŠŸèƒ½æ€§æµ‹è¯•ç»“æœ
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void BLE_test_result(const unsigned char value[], unsigned short length)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è“ç‰™åŠŸèƒ½æ€§æµ‹è¯•ç»“æœä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char sub_cmd = value[0];
                  
                  if(0x03 != length) {
                      //æ•°æ®é•¿åº¦é”™è¯¯
                      return;
                  }
                  
                  if(0x01 != sub_cmd) {
                      //å­å‘½ä»¤é”™è¯¯
                      return;
                  }
                  
                  unsigned char result = value[1];
                  unsigned char rssi = value[2];
                      
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 26  

                  if(result == 0) {
                      //æµ‹è¯•å¤±è´¥
                      if(rssi == 0x00) {
                          //æœªæ‰«æåˆ°åç§°ä¸º ty_mdevè“ç‰™ä¿¡æ ‡,è¯·æ£€æŸ¥
                      }else if(rssi == 0x01) {
                          //æ¨¡å—æœªæˆæƒ
                      }
                  }else if(result == 0x01) {
                      //æµ‹è¯•æˆåŠŸ
                      //rssiä¸ºä¿¡å·å¼ºåº¦(0-100, 0ä¿¡å·æœ€å·®ï¼Œ100ä¿¡å·æœ€å¼º)
                  }
              }
              #endif
1542          
1543          #ifdef VOICE_MODULE_PROTOCOL_ENABLE
              /**
               * @brief  è·å–è¯­éŸ³çŠ¶æ€ç ç»“æœ
               * @param[in] {result} è¯­éŸ³çŠ¶æ€ç 
               * @ref       0x00: ç©ºé—²
               * @ref       0x01: micé™éŸ³çŠ¶æ€
               * @ref       0x02: å”¤é†’
               * @ref       0x03: æ­£åœ¨å½•éŸ³
               * @ref       0x04: æ­£åœ¨è¯†åˆ«
               * @ref       0x05: è¯†åˆ«æˆåŠŸ
               * @ref       0x06: è¯†åˆ«å¤±è´¥
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_voice_state_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è·å–è¯­éŸ³çŠ¶æ€ç ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0:
                          //ç©ºé—²
                      break;
                  
                      case 1:
                          //micé™éŸ³çŠ¶æ€
                      break;
                      
                      case 2:
                          //å”¤é†’
                      break;
                      
                      case 3:
                          //æ­£åœ¨å½•éŸ³
                      break;
                      
                      case 4:
                          //æ­£åœ¨è¯†åˆ«
                      break;
                  
                      case 5:
                          //è¯†åˆ«æˆåŠŸ
                      break;
                      
                      case 6:
                          //è¯†åˆ«å¤±è´¥
                      break;
                      
                    default:break;
                  }
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 27  

              }
              
              /**
               * @brief  MICé™éŸ³è®¾ç½®ç»“æœ
               * @param[in] {result} è¯­éŸ³çŠ¶æ€ç 
               * @ref       0x00: mic å¼€å¯
               * @ref       0x01: mic é™éŸ³
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void set_voice_MIC_silence_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°MICé™éŸ³è®¾ç½®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0) {
                      //mic å¼€å¯
                  }else {
                      //mic é™éŸ³
                  }
              }
              
              /**
               * @brief  speakeréŸ³é‡è®¾ç½®ç»“æœ
               * @param[in] {result} éŸ³é‡å€¼
               * @ref       0~10: éŸ³é‡èŒƒå›´
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void set_speaker_voice_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°speakeréŸ³é‡è®¾ç½®ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  
              }
              
              /**
               * @brief  éŸ³é¢‘äº§æµ‹ç»“æœ
               * @param[in] {result} éŸ³é¢‘äº§æµ‹çŠ¶æ€
               * @ref       0x00: å…³é—­éŸ³é¢‘äº§æµ‹
               * @ref       0x01: mic1éŸ³é¢‘ç¯è·¯æµ‹è¯•
               * @ref       0x02: mic2éŸ³é¢‘ç¯è·¯æµ‹è¯•
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°éŸ³é¢‘äº§æµ‹ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0x00) {
                      //å…³é—­éŸ³é¢‘äº§æµ‹
                  }else if(result == 0x01) {
                      //mic1éŸ³é¢‘ç¯è·¯æµ‹è¯•
                  }else if(result == 0x02) {
                      //mic2éŸ³é¢‘ç¯è·¯æµ‹è¯•
                  }
              }
              
              /**
               * @brief  å”¤é†’äº§æµ‹ç»“æœ
               * @param[in] {result} å”¤é†’è¿”å›å€¼
               * @ref       0x00: å”¤é†’æˆåŠŸ
               * @ref       0x01: å”¤é†’å¤±è´¥(10sè¶…æ—¶å¤±è´¥)
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 28  

              void voice_awaken_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°å”¤é†’äº§æµ‹ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0x00) {
                      //å”¤é†’æˆåŠŸ
                  }else if(result == 0x01) {
                      //å”¤é†’å¤±è´¥
                  }
              }
              
              /**
               * @brief  è¯­éŸ³æ¨¡ç»„æ‰©å±•åŠŸèƒ½
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_module_extend_fun(const unsigned char value[], unsigned short length)
              {
                  unsigned char sub_cmd = value[0];
                  unsigned char play;
                  unsigned char bt_play;
                  unsigned short send_len = 0;
                
                  switch(sub_cmd) {
                      case 0x00: { //å­å‘½ä»¤  MCUåŠŸèƒ½è®¾ç½®
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x01: {  //å­å‘½ä»¤  çŠ¶æ€é€šçŸ¥
                          if(0x02 > length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          unsigned char play = 0xff;
                          unsigned char bt_play = 0xff;
                          
                          const char *str_buff = (const char *)&value[1];
                          const char *str_result = NULL;
                          
                          str_result = strstr(str_buff,"play") + my_strlen("play") + 2;
                          if(NULL == str_result) {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          if(0 == memcmp(str_result, "true", my_strlen("true"))) {
                              play = 1;
                          }else if(0 == memcmp(str_result, "false", my_strlen("false"))) {
                              play = 0;
                          }else {
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/21/2020 10:49:10 PAGE 29  

                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          str_result = strstr(str_buff,"bt_play") + my_strlen("bt_play") + 2;
                          if(NULL == str_result) {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          if(0 == memcmp(str_result, "true", my_strlen("true"))) {
                              bt_play = 1;
                          }else if(0 == memcmp(str_result, "false", my_strlen("false"))) {
                              bt_play = 0;
                          }else {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          #error "è¯·è‡ªè¡Œå®ç°è¯­éŸ³æ¨¡ç»„çŠ¶æ€é€šçŸ¥å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                          //MCUè®¾ç½®æš‚ä»…æ”¯æŒâ€æ’­æ”¾/æš‚åœâ€ â€è“ç‰™å¼€å…³â€
                          //play    æ’­æ”¾/æš‚åœåŠŸèƒ½  1(æ’­æ”¾) / 0(æš‚åœ)
                          //bt_play è“ç‰™å¼€å…³åŠŸèƒ½   1(å¼€)   / 0(å…³)
                          
                          
                          
                          send_len = 0;
                          send_len = set_wifi_uart_byte(send_len, sub_cmd);
                          send_len = set_wifi_uart_byte(send_len, 0x00);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
              
                      default:break;
                  }
                  
                  return;
              
              ERR_EXTI:
                  send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, sub_cmd);
                  send_len = set_wifi_uart_byte(send_len, 0x01);
                  wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                  return;
              }
              #endif
1761          
1762          
1763          
1764          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1142    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     23    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      26
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
