C51 COMPILER V9.52.0.0   SYSTEM                                                            10/21/2020 10:49:10 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE SYSTEM
OBJECT MODULE PLACED IN .\Objects\system.obj
COMPILER INVOKED BY: d:\cccc2020\TOOL\Keil\C51\BIN\C51.EXE ..\User\system.c OPTIMIZE(SIZE) BROWSE DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\system.lst) TABS(2) OBJECT(.\Objects\system.obj)

line level    source

   1          /**********************************Copyright (c)**********************************
   2          **                       ç‰ˆæƒæ‰€æœ‰ (C), 2015-2020, æ¶‚é¸¦ç§‘æŠ€
   3          **
   4          **                             http://www.tuya.com
   5          **
   6          *********************************************************************************/
   7          /**
   8           * @file    system.c
   9           * @author  æ¶‚é¸¦ç»¼åˆåè®®å¼€å‘ç»„
  10           * @version v2.5.5
  11           * @date    2020.6.1
  12           * @brief   ä¸²å£æ•°æ®å¤„ç†ï¼Œç”¨æˆ·æ— éœ€å…³å¿ƒè¯¥æ–‡ä»¶å®ç°å†…å®¹
  13           */
  14           
  15          
  16          #define SYSTEM_GLOBAL
  17          
  18          #include "wifi.h"
  19          #include "HC89S003F4.h"
  20          
  21          void savevar(void);
  22          extern const DOWNLOAD_CMD_S xdata download_cmd[];
  23          
  24          
  25          
  26          /**
  27           * @brief  å†™wifi_uartå­—èŠ‚
  28           * @param[in] {dest} ç¼“å­˜åŒºå…¶å®åœ°å€
  29           * @param[in] {byte} å†™å…¥å­—èŠ‚å€¼
  30           * @return å†™å…¥å®Œæˆåçš„æ€»é•¿åº¦
  31           */
  32          unsigned short set_wifi_uart_byte(unsigned short dest, unsigned char byte)
  33          {
  34   1          unsigned char *obj = (unsigned char *)wifi_uart_tx_buf + DATA_START + dest;
  35   1          
  36   1          *obj = byte;
  37   1          dest += 1;
  38   1          
  39   1          return dest;
  40   1      }
  41          
  42          /**
  43           * @brief  å†™wifi_uart_buffer
  44           * @param[in] {dest} ç›®æ ‡åœ°å€
  45           * @param[in] {src} æºåœ°å€
  46           * @param[in] {len} æ•°æ®é•¿åº¦
  47           * @return å†™å…¥ç»“æŸçš„ç¼“å­˜åœ°å€
  48           */
  49          unsigned short set_wifi_uart_buffer(unsigned short dest, const unsigned char *src, unsigned short len)
  50          {
  51   1          unsigned char *obj = (unsigned char *)wifi_uart_tx_buf + DATA_START + dest;
  52   1          
  53   1          my_memcpy(obj,src,len);
  54   1          
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/21/2020 10:49:10 PAGE 2   

  55   1          dest += len;
  56   1          return dest;
  57   1      }
  58          
  59          /**
  60           * @brief  è®¡ç®—æ ¡éªŒå’Œ
  61           * @param[in] {pack} æ•°æ®æºæŒ‡é’ˆ
  62           * @param[in] {pack_len} è®¡ç®—æ ¡éªŒå’Œé•¿åº¦
  63           * @return æ ¡éªŒå’Œ
  64           */
  65          unsigned char get_check_sum(unsigned char *pack, unsigned short pack_len)
  66          {
  67   1          unsigned short i;
  68   1          unsigned char check_sum = 0;
  69   1          
  70   1          for(i = 0; i < pack_len; i ++) {
  71   2              check_sum += *pack ++;
  72   2          }
  73   1          
  74   1          return check_sum;
  75   1      }
  76          
  77          /**
  78           * @brief  ä¸²å£å‘é€ä¸€æ®µæ•°æ®
  79           * @param[in] {in} å‘é€ç¼“å­˜æŒ‡é’ˆ
  80           * @param[in] {len} æ•°æ®å‘é€é•¿åº¦
  81           * @return Null
  82           */
  83          static void wifi_uart_write_data(unsigned char *in, unsigned short len)
  84          {
  85   1        if((NULL == in) || (0 == len)) {
  86   2            return;
  87   2        }
  88   1        
  89   1        while(len --) {
  90   2            uart_transmit_output(*in);
  91   2            in ++;
  92   2        }
  93   1      }
  94          
  95          /**
  96           * @brief  å‘wifiä¸²å£å‘é€ä¸€å¸§æ•°æ®
  97           * @param[in] {fr_type} å¸§ç±»å‹
  98           * @param[in] {fr_ver} å¸§ç‰ˆæœ¬
  99           * @param[in] {len} æ•°æ®é•¿åº¦
 100           * @return Null
 101           */
 102          void wifi_uart_write_frame(unsigned char fr_type, unsigned char fr_ver, unsigned short len)
 103          {
 104   1          unsigned char check_sum = 0;
 105   1          
 106   1          wifi_uart_tx_buf[HEAD_FIRST] = 0x55;
 107   1          wifi_uart_tx_buf[HEAD_SECOND] = 0xaa;
 108   1          wifi_uart_tx_buf[PROTOCOL_VERSION] = fr_ver;
 109   1          wifi_uart_tx_buf[FRAME_TYPE] = fr_type;
 110   1          wifi_uart_tx_buf[LENGTH_HIGH] = len >> 8;
 111   1          wifi_uart_tx_buf[LENGTH_LOW] = len & 0xff;
 112   1          
 113   1          len += PROTOCOL_HEAD;
 114   1          check_sum = get_check_sum((unsigned char *)wifi_uart_tx_buf, len - 1);
 115   1          wifi_uart_tx_buf[len - 1] = check_sum;
 116   1          
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/21/2020 10:49:10 PAGE 3   

 117   1          wifi_uart_write_data((unsigned char *)wifi_uart_tx_buf, len);
 118   1      }
 119          
 120          /**
 121           * @brief  å¿ƒè·³åŒ…æ£€æµ‹
 122           * @param  Null
 123           * @return Null
 124           */
 125          static void heat_beat_check(void)
 126          {
 127   1          unsigned char length = 0;
 128   1          static unsigned char mcu_reset_state = FALSE;
 129   1          
 130   1          if(FALSE == mcu_reset_state) {
 131   2              length = set_wifi_uart_byte(length, FALSE);
 132   2              mcu_reset_state = TRUE;
 133   2          }else {
 134   2              length = set_wifi_uart_byte(length, TRUE);
 135   2          }
 136   1          
 137   1          wifi_uart_write_frame(HEAT_BEAT_CMD, MCU_TX_VER, length);
 138   1      }
 139          
 140          /**
 141           * @brief  äº§å“ä¿¡æ¯ä¸Šä¼ 
 142           * @param  Null
 143           * @return Null
 144           */
 145          static void product_info_update(void)
 146          {
 147   1          unsigned char length = 0;
 148   1          unsigned char str[10] = {0};
 149   1          
 150   1          length = set_wifi_uart_buffer(length, "{\"p\":\"", my_strlen("{\"p\":\""));
 151   1          length = set_wifi_uart_buffer(length,(unsigned char *)PRODUCT_KEY,my_strlen((unsigned char *)PRODUCT_K
             -EY));
 152   1          length = set_wifi_uart_buffer(length, "\",\"v\":\"", my_strlen("\",\"v\":\""));
 153   1          length = set_wifi_uart_buffer(length,(unsigned char *)MCU_VER,my_strlen((unsigned char *)MCU_VER));
 154   1          length = set_wifi_uart_buffer(length, "\",\"m\":", my_strlen("\",\"m\":"));
 155   1          length = set_wifi_uart_buffer(length, (unsigned char *)CONFIG_MODE, my_strlen((unsigned char *)CONFIG_
             -MODE));
 156   1      #ifdef CONFIG_MODE_DELAY_TIME
                  sprintf((char *)str,",\"mt\":%d",CONFIG_MODE_DELAY_TIME);
                  length = set_wifi_uart_buffer(length, str, my_strlen(str));
              #endif
 160   1      #ifdef CONFIG_MODE_CHOOSE
                  sprintf((char *)str,",\"n\":%d",CONFIG_MODE_CHOOSE);
                  length = set_wifi_uart_buffer(length, str, my_strlen(str));
              #endif
 164   1      #ifdef ENABLE_MODULE_IR_FUN
                  sprintf((char *)str,",\"ir\":\"%d.%d\"",MODULE_IR_PIN_TX,MODULE_IR_PIN_RX);
                  length = set_wifi_uart_buffer(length, str, my_strlen(str));
              #endif
 168   1      #ifdef LONG_CONN_LOWPOWER
                  sprintf((char *)str,",\"low\":%d",LONG_CONN_LOWPOWER);
                  length = set_wifi_uart_buffer(length, str, my_strlen(str));
              #endif
 172   1        
 173   1          length = set_wifi_uart_buffer(length, "}", my_strlen("}"));
 174   1          
 175   1          wifi_uart_write_frame(PRODUCT_INFO_CMD, MCU_TX_VER, length);
 176   1      }
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/21/2020 10:49:10 PAGE 4   

 177          
 178          /**
 179           * @brief  mcuæŸ¥è¯¢mcuå’Œwifiçš„å·¥ä½œæ¨¡å¼
 180           * @param  Null
 181           * @return Null
 182           */
 183          static void get_mcu_wifi_mode(void)
 184          {
 185   1          unsigned char length = 0;
 186   1          
 187   1      #ifdef WIFI_CONTROL_SELF_MODE                                   //æ¨¡å—è‡ªå¤„ç†
                  length = set_wifi_uart_byte(length, WF_STATE_KEY);
                  length = set_wifi_uart_byte(length, WF_RESERT_KEY);
              #else                                                           
 191   1          //No need to process data
 192   1      #endif
 193   1          
 194   1          wifi_uart_write_frame(WORK_MODE_CMD, MCU_TX_VER, length);
 195   1      }
 196          
 197          /**
 198           * @brief  è·å–åˆ¶å®šDPIDåœ¨æ•°ç»„ä¸­çš„åºå·
 199           * @param[in] {dpid} dpid
 200           * @return dpåºå·
 201           */
 202          static unsigned char get_dowmload_dpid_index(unsigned char dpid)
 203          {
 204   1          unsigned char index;
 205   1          unsigned char total = get_download_cmd_total();
 206   1          
 207   1          for(index = 0; index < total; index ++) {
 208   2              if(download_cmd[index].dp_id == dpid) {
 209   3                  break;
 210   3              }
 211   2          }
 212   1          
 213   1          return index;
 214   1      }
 215          
 216          /**
 217           * @brief  ä¸‹å‘æ•°æ®å¤„ç†
 218           * @param[in] {value} ä¸‹å‘æ•°æ®æºæŒ‡é’ˆ
 219           * @return è¿”å›æ•°æ®å¤„ç†ç»“æœ
 220           */
 221          static unsigned char data_point_handle(const unsigned char value[])
 222          {
 223   1          unsigned char dp_id,index;
 224   1          unsigned char dp_type;
 225   1          unsigned char ret;
 226   1          unsigned short dp_len;
 227   1          
 228   1          dp_id = value[0];
 229   1          dp_type = value[1];
 230   1          dp_len = value[2] * 0x100;
 231   1          dp_len += value[3];
 232   1          
 233   1          index = get_dowmload_dpid_index(dp_id);
 234   1      
 235   1          if(dp_type != download_cmd[index].dp_type) {
 236   2              //é”™è¯¯æç¤º
 237   2              return FALSE;
 238   2          }else {
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/21/2020 10:49:10 PAGE 5   

 239   2              ret = dp_download_handle(dp_id,value + 4,dp_len);
 240   2          }
 241   1          
 242   1          return ret;
 243   1      }
 244          
 245          #ifdef WEATHER_ENABLE
              /**
               * @brief  å¤©æ°”æ•°æ®è§£æ
               * @param[in] {p_data} æ¥æ”¶æ•°æ®æŒ‡é’ˆ
               * @param[in] {data_len} æ¥æ”¶æ•°æ®é•¿åº¦
               * @return Null
               */
              static void weather_data_raw_handle(const unsigned char p_data[], unsigned short data_len)
              {
                  int i = 1;
                  int can_len = 0; 
                  char can[15] = {0};
                  char day = 0;
                  int type1 = 0;
                  unsigned char value_string[100] = {0};
                  int val_cnt = 0;
                  int val_len = 0;
                  
                  if(p_data[0] != 1 || data_len < 1) {
                      //æ¥æ”¶å¤±è´¥
                  }else {
                      if(data_len < 4) {
                          //æ•°æ®ä¸ºç©º
                      }
                      
                      while (i < data_len) {
                          can_len = p_data[i];
                          
                          my_memset(can, '\0', 15);
                          my_memcpy(can, p_data + i + 1, can_len - 2);
              
                          day = p_data[i + can_len] - '0';
              
                          type1 = p_data[i + 1 + can_len];
                          if(type1 != 0 && type1 != 1) {
                              return;
                          }
              
                          my_memset(value_string, '\0', 100);
                          val_cnt = i + 1 + can_len + 1;
                          val_len = p_data[val_cnt];
                          if (type1 == 0) { //int32
                              weather_data_user_handle(can+2, type1, p_data+val_cnt+1, day);
                          }
                          else if(type1 == 1) { //string
                              my_memcpy(value_string, p_data + val_cnt + 1, val_len);
                              weather_data_user_handle(can+2, type1, value_string, day);
                          }
              
                          i += 1 + can_len + 1 + 1 + val_len;
                      }
                      
                      wifi_uart_write_frame(WEATHER_DATA_CMD, 0, 0);
                  }
              }
              #endif
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/21/2020 10:49:10 PAGE 6   

 301          
 302          #ifdef WIFI_STREAM_ENABLE
              /**
               * @brief  æµæ•°æ®ä¼ è¾“
               * @param[in] {id} æµæœåŠ¡æ ‡è¯†
               * @param[in] {offset} åç§»é‡
               * @param[in] {buffer} æ•°æ®åœ°å€
               * @param[in] {buf_len} æ•°æ®é•¿åº¦
               * @return Null
               * @note   Null
               */
              unsigned char stream_trans(unsigned short id, unsigned int offset, unsigned char *buffer, unsigned short b
             -uf_len)
              {
                  unsigned short send_len = 0;
              
                  stream_status = 0xff;
              
                  if(stop_update_flag == ENABLE)
                      return ERROR;
              
                  //ID
                  send_len = set_wifi_uart_byte(send_len,id / 0x100);
                  send_len = set_wifi_uart_byte(send_len,id % 0x100);
                  //Offset
                  send_len = set_wifi_uart_byte(send_len,offset >> 24);
                  send_len = set_wifi_uart_byte(send_len,offset >> 16);
                  send_len = set_wifi_uart_byte(send_len,offset >> 8);
                  send_len = set_wifi_uart_byte(send_len,offset % 256);
                  //data
                  send_len = set_wifi_uart_buffer(send_len, buffer, buf_len);
                  wifi_uart_write_frame(STREAM_TRANS_CMD, MCU_TX_VER, send_len);
                  return SUCCESS;
              }
              
              /**
               * @brief  å¤šåœ°å›¾æµæ•°æ®ä¼ è¾“
               * @param[in] {pro_ver} åœ°å›¾æœåŠ¡åè®®ç‰ˆæœ¬
               * @param[in] {id} åœ°å›¾æµæœåŠ¡ä¼šè¯ID
               * @param[in] {sub_id} å­åœ°å›¾ID
               * @param[in] {sub_id_pro_mode} å­åœ°å›¾IDæ•°æ®å¤„ç†æ–¹å¼
               * @ref           0x00:ç»§ç»­ç´¯åŠ 
               * @ref           0x00:æ¸…é™¤ä¸Šä¼ çš„æ•°æ®
               * @param[in] {offset} åç§»é‡
               * @param[in] {buffer} æ•°æ®åœ°å€
               * @param[in] {buf_len} æ•°æ®é•¿åº¦
               * @return Null
               * @note   Null
               */
              unsigned char maps_stream_trans(unsigned char pro_ver, unsigned short id, unsigned char sub_id, unsigned c
             -har sub_id_pro_mode, 
                                              unsigned int offset, unsigned char *buffer, unsigned short buf_len)
              {
                  unsigned short send_len = 0;
              
                  maps_stream_status = 0xff;
              
                  if(stop_update_flag == ENABLE)
                      return ERROR;
              
                  //åœ°å›¾æœåŠ¡åè®®ç‰ˆæœ¬
                  send_len = set_wifi_uart_byte(send_len, pro_ver);
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/21/2020 10:49:10 PAGE 7   

                  
                  //åœ°å›¾æµæœåŠ¡ä¼šè¯ID
                  send_len = set_wifi_uart_byte(send_len,id / 0x100);
                  send_len = set_wifi_uart_byte(send_len,id % 0x100);
                  
                  //å­åœ°å›¾ID
                  send_len = set_wifi_uart_byte(send_len, sub_id);
                  
                  //å­åœ°å›¾IDæ•°æ®å¤„ç†æ–¹å¼
                  send_len = set_wifi_uart_byte(send_len, sub_id_pro_mode);
                  
                  //åç§»é‡
                  send_len = set_wifi_uart_byte(send_len,offset >> 24);
                  send_len = set_wifi_uart_byte(send_len,offset >> 16);
                  send_len = set_wifi_uart_byte(send_len,offset >> 8);
                  send_len = set_wifi_uart_byte(send_len,offset % 256);
                  //Data
                  send_len = set_wifi_uart_buffer(send_len, buffer, buf_len);
                  wifi_uart_write_frame(MAPS_STREAM_TRANS_CMD, MCU_TX_VER, send_len);
                  return SUCCESS;
              }
              #endif
 383          
 384          /**
 385           * @brief  æ•°æ®å¸§å¤„ç†
 386           * @param[in] {offset} æ•°æ®èµ·å§‹ä½
 387           * @return Null
 388           */
 389          void data_handle(unsigned short offset)
 390          {
 391   1      #ifdef SUPPORT_MCU_FIRM_UPDATE
                  unsigned char *firmware_addr = NULL;
                  static unsigned short firm_size;                                            //å‡çº§åŒ…ä¸€åŒ…çš„å¤§å°
                  static unsigned long firm_length;                                           //MCUå‡çº§æ–‡ä»¶é•¿åº¦
                  static unsigned char firm_update_flag = 0;                                  //MCUå‡çº§æ ‡å¿—
                  unsigned long dp_len;
                  unsigned char firm_flag;                                                    //å‡çº§åŒ…å¤§å°æ ‡å¿—
              #else
 399   1          unsigned short dp_len;
 400   1      #endif
 401   1        
 402   1          unsigned char ret;
 403   1          unsigned short i,total_len;
 404   1          unsigned char cmd_type = wifi_data_process_buf[offset + FRAME_TYPE];
 405   1          unsigned char result;
 406   1      
 407   1      #ifdef WEATHER_ENABLE
                  static unsigned char isWoSend = 0;                                          //æ˜¯å¦å·²ç»æ‰“å¼€è¿‡å¤©
             -æ°”æ•°æ®, 0:å¦  1:æ˜¯
              #endif
 410   1      
 411   1      #ifdef WIFI_TEST_ENABLE
 412   1          unsigned char rssi;
 413   1      #endif
 414   1      
 415   1      #ifdef FILE_DOWNLOAD_ENABLE
                  unsigned char *file_data_addr = NULL;
                  static unsigned short file_package_size = 0;                                //æ–‡ä»¶æ•°æ®åŒ…ä¸€åŒ…çš„
             -å¤§å°
                  static unsigned char file_download_flag = 0;                                //æ–‡ä»¶ä¸‹è½½æ ‡å¿—
                  unsigned int file_download_size = 0;
              #endif
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/21/2020 10:49:10 PAGE 8   

 421   1      
 422   1          switch(cmd_type)
 423   1          {
 424   2              case HEAT_BEAT_CMD:                                     //å¿ƒè·³åŒ…
 425   2                  heat_beat_check();
 426   2              break;
 427   2          
 428   2              case PRODUCT_INFO_CMD:                                  //äº§å“ä¿¡æ¯
 429   2                  product_info_update();
 430   2              break;
 431   2          
 432   2              case WORK_MODE_CMD:                                     //æŸ¥è¯¢MCUè®¾å®šçš„æ¨¡å—å·¥ä½œæ¨¡å¼
 433   2                  get_mcu_wifi_mode();
 434   2              break;
 435   2          
 436   2      #ifndef WIFI_CONTROL_SELF_MODE
 437   2              case WIFI_STATE_CMD:                                    //wifiå·¥ä½œçŠ¶æ€  
 438   2                  wifi_work_state = wifi_data_process_buf[offset + DATA_START];
 439   2                  wifi_uart_write_frame(WIFI_STATE_CMD, MCU_TX_VER, 0);
 440   2      #ifdef WEATHER_ENABLE
                          if(wifi_work_state == WIFI_CONNECTED && isWoSend == 0) { //å½“WIFIè¿æ¥æˆåŠŸï¼Œæ‰“å¼€å¤©æ°”æ
             -•°æ®ä¸”ä»…ä¸€æ¬¡
                              mcu_open_weather();
                              isWoSend = 1;
                          }
              #endif
 446   2              break;
 447   2      
 448   2              case WIFI_RESET_CMD:                                    //é‡ç½®wifi(wifiè¿”å›æˆåŠŸ)
 449   2                  reset_wifi_flag = RESET_WIFI_SUCCESS;
 450   2              break;
 451   2          
 452   2              case WIFI_MODE_CMD:                                     //é€‰æ‹©smartconfig/APæ¨¡å¼(wifiè¿”å›æˆ
             -åŠŸ)  
 453   2                  set_wifimode_flag = SET_WIFICONFIG_SUCCESS;
 454   2              break;
 455   2      #endif
 456   2          
 457   2              case DATA_QUERT_CMD:                                    //å‘½ä»¤ä¸‹å‘
 458   2                  total_len = (wifi_data_process_buf[offset + LENGTH_HIGH] << 8) | wifi_data_process_buf[offset 
             -+ LENGTH_LOW];
 459   2          
 460   2                  for(i = 0;i < total_len; ) {
 461   3                      dp_len = wifi_data_process_buf[offset + DATA_START + i + 2] * 0x100;
 462   3                      dp_len += wifi_data_process_buf[offset + DATA_START + i + 3];
 463   3                      //
 464   3                      ret = data_point_handle((unsigned char *)wifi_data_process_buf + offset + DATA_START + i);
 465   3            
 466   3                      if(SUCCESS == ret) {
 467   4                          //æˆåŠŸæç¤º
 468   4                      }else {
 469   4                          //é”™è¯¯æç¤º
 470   4                      }
 471   3            
 472   3                      i += (dp_len + 4);
 473   3                  }
 474   2              break;
 475   2          
 476   2              case STATE_QUERY_CMD:                                   //çŠ¶æ€æŸ¥è¯¢
 477   2                  all_data_update();                               
 478   2              break;
 479   2          
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/21/2020 10:49:10 PAGE 9   

 480   2      #ifdef SUPPORT_MCU_FIRM_UPDATE
                      case UPDATE_START_CMD:                                  //å‡çº§å¼€å§‹
                          //è·å–å‡çº§åŒ…å¤§å°å…¨å±€å˜é‡
                          firm_flag = PACKAGE_SIZE;
                          if(firm_flag == 0) {
                              firm_size = 256;
                          }else if(firm_flag == 1) {
                              firm_size = 512;
                          }else if(firm_flag == 2) { 
                              firm_size = 1024;
                          }
              
                          firm_length = wifi_data_process_buf[offset + DATA_START];
                          firm_length <<= 8;
                          firm_length |= wifi_data_process_buf[offset + DATA_START + 1];
                          firm_length <<= 8;
                          firm_length |= wifi_data_process_buf[offset + DATA_START + 2];
                          firm_length <<= 8;
                          firm_length |= wifi_data_process_buf[offset + DATA_START + 3];
                          
                          upgrade_package_choose(PACKAGE_SIZE);
                          firm_update_flag = UPDATE_START_CMD;
                      break;
                  
                      case UPDATE_TRANS_CMD:                                  //å‡çº§ä¼ è¾“
                          if(firm_update_flag == UPDATE_START_CMD) {
                              //åœæ­¢ä¸€åˆ‡æ•°æ®ä¸ŠæŠ¥
                              stop_update_flag = ENABLE;
                    
                              total_len = (wifi_data_process_buf[offset + LENGTH_HIGH] << 8) | wifi_data_process_buf[off
             -set + LENGTH_LOW];
                    
                              dp_len = wifi_data_process_buf[offset + DATA_START];
                              dp_len <<= 8;
                              dp_len |= wifi_data_process_buf[offset + DATA_START + 1];
                              dp_len <<= 8;
                              dp_len |= wifi_data_process_buf[offset + DATA_START + 2];
                              dp_len <<= 8;
                              dp_len |= wifi_data_process_buf[offset + DATA_START + 3];
                    
                              firmware_addr = (unsigned char *)wifi_data_process_buf;
                              firmware_addr += (offset + DATA_START + 4);
                    
                              if((total_len == 4) && (dp_len == firm_length)) {
                                  //æœ€åä¸€åŒ…
                                  ret = mcu_firm_update_handle(firmware_addr,dp_len,0);
                                  firm_update_flag = 0;
                              }else if((total_len - 4) <= firm_size) {
                                  ret = mcu_firm_update_handle(firmware_addr,dp_len,total_len - 4);
                              }else {
                                  firm_update_flag = 0;
                                  ret = ERROR;
                              }
                    
                              if(ret == SUCCESS) {
                                  wifi_uart_write_frame(UPDATE_TRANS_CMD, MCU_TX_VER, 0);
                              }
                              //æ¢å¤ä¸€åˆ‡æ•°æ®ä¸ŠæŠ¥
                              stop_update_flag = DISABLE;    
                          }
                      break;
              #endif      
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/21/2020 10:49:10 PAGE 10  

 541   2      
 542   2      #ifdef SUPPORT_GREEN_TIME
                      case GET_ONLINE_TIME_CMD:                               //è·å–æ ¼æ—æ—¶é—´
                          mcu_get_greentime((unsigned char *)(wifi_data_process_buf + offset + DATA_START));
                      break;
              #endif
 547   2      
 548   2      #ifdef SUPPORT_MCU_RTC_CHECK
                      case GET_LOCAL_TIME_CMD:                               //è·å–æœ¬åœ°æ—¶é—´
                          mcu_write_rtctime((unsigned char *)(wifi_data_process_buf + offset + DATA_START));
                      break;
              #endif
 553   2       
 554   2      #ifdef WIFI_TEST_ENABLE
 555   2              case WIFI_TEST_CMD:                                     //wifiåŠŸèƒ½æµ‹è¯•ï¼ˆæ‰«ææŒ‡å®šè·¯ç”±ï¼‰
 556   2                  result = wifi_data_process_buf[offset + DATA_START];
 557   2                  rssi = wifi_data_process_buf[offset + DATA_START + 1];
 558   2                  wifi_test_result(result, rssi);
 559   2              break;
 560   2      #endif
 561   2      
 562   2      #ifdef WEATHER_ENABLE
                      case WEATHER_OPEN_CMD:                                  //æ‰“å¼€å¤©æ°”æœåŠ¡è¿”å›
                          weather_open_return_handle(wifi_data_process_buf[offset + DATA_START], wifi_data_process_buf[o
             -ffset + DATA_START + 1]);
                      break;
                  
                      case WEATHER_DATA_CMD:                                  //å¤©æ°”æ•°æ®ä¸‹å‘
                          total_len = (wifi_data_process_buf[offset + LENGTH_HIGH] << 8) | wifi_data_process_buf[offset 
             -+ LENGTH_LOW];
                          weather_data_raw_handle((unsigned char *)wifi_data_process_buf + offset + DATA_START, total_le
             -n);
                      break;
              #endif
 572   2      
 573   2      #ifdef WIFI_STREAM_ENABLE
                      case STREAM_TRANS_CMD:                                  //æµæœåŠ¡
                          stream_status = wifi_data_process_buf[offset + DATA_START];//æµæœåŠ¡ä¼ è¾“è¿”å›æ¥æ”¶
                          stream_trans_send_result(stream_status);
                      break;
                      
                      case MAPS_STREAM_TRANS_CMD:                             //æµæ•°æ®ä¼ è¾“(æ”¯æŒå¤šå¼ åœ°å›¾)
                          maps_stream_status = wifi_data_process_buf[offset + DATA_START];//æµæœåŠ¡ä¼ è¾“è¿”å›æ¥æ”¶
                          maps_stream_trans_send_result(maps_stream_status);
                      break;
              #endif
 584   2      
 585   2      #ifdef WIFI_CONNECT_TEST_ENABLE
                      case WIFI_CONNECT_TEST_CMD:                             //wifiåŠŸèƒ½æµ‹è¯•ï¼ˆè¿æ¥æŒ‡å®šè·¯ç”±ï¼‰
                          result = wifi_data_process_buf[offset + DATA_START];
                          wifi_connect_test_result(result);
                      break;
              #endif
 591   2      
 592   2      #ifdef GET_MODULE_MAC_ENABLE
                      case GET_MAC_CMD:                                       //è·å–æ¨¡å—mac
                          mcu_get_mac((unsigned char *)(wifi_data_process_buf + offset + DATA_START));
                      break;
              #endif
 597   2      
 598   2      #ifdef GET_WIFI_STATUS_ENABLE
                      case GET_WIFI_STATUS_CMD:                               //è·å–å½“å‰wifiè”ç½‘çŠ¶æ€
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/21/2020 10:49:10 PAGE 11  

                          result = wifi_data_process_buf[offset + DATA_START];
                          get_wifi_status(result);
                      break;
              #endif
 604   2      
 605   2      #ifdef MCU_DP_UPLOAD_SYN
                      case STATE_UPLOAD_SYN_RECV_CMD:                         //çŠ¶æ€ä¸ŠæŠ¥ï¼ˆåŒæ­¥ï¼‰
                          result = wifi_data_process_buf[offset + DATA_START];
                          get_upload_syn_result(result);
                      break;
              #endif
 611   2      
 612   2      #ifdef GET_IR_STATUS_ENABLE
                      case GET_IR_STATUS_CMD:                                 //çº¢å¤–çŠ¶æ€é€šçŸ¥
                          result = wifi_data_process_buf[offset + DATA_START];
                          get_ir_status(result);
                      break;
              #endif
 618   2            
 619   2      #ifdef IR_TX_RX_TEST_ENABLE
                      case IR_TX_RX_TEST_CMD:                                 //çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹
                          result = wifi_data_process_buf[offset + DATA_START];
                          ir_tx_rx_test_result(result);
                      break;
              #endif
 625   2              
 626   2      #ifdef FILE_DOWNLOAD_ENABLE
                      case FILE_DOWNLOAD_START_CMD:                           //æ–‡ä»¶ä¸‹è½½å¯åŠ¨
                          //è·å–æ–‡ä»¶åŒ…å¤§å°é€‰æ‹©
                          if(FILE_DOWNLOAD_PACKAGE_SIZE == 0) {
                              file_package_size = 256;
                          }else if(FILE_DOWNLOAD_PACKAGE_SIZE == 1) {
                              file_package_size = 512;
                          }else if(FILE_DOWNLOAD_PACKAGE_SIZE == 2) { 
                              file_package_size = 1024;
                          }
                          
                          file_download_size = wifi_data_process_buf[offset + DATA_START];
                          file_download_size = (file_download_size << 8) |  wifi_data_process_buf[offset + DATA_START + 
             -1];
                          file_download_size = (file_download_size << 8) |  wifi_data_process_buf[offset + DATA_START + 
             -2];
                          file_download_size = (file_download_size << 8) |  wifi_data_process_buf[offset + DATA_START + 
             -3];
                      
                          file_download_package_choose(FILE_DOWNLOAD_PACKAGE_SIZE);
                          file_download_flag = FILE_DOWNLOAD_START_CMD;
                      break;
                      
                      case FILE_DOWNLOAD_TRANS_CMD:                           //æ–‡ä»¶ä¸‹è½½æ•°æ®ä¼ è¾“
                          if(file_download_flag == FILE_DOWNLOAD_START_CMD) {
                              total_len = (wifi_data_process_buf[offset + LENGTH_HIGH] << 8) | wifi_data_process_buf[off
             -set + LENGTH_LOW];
                    
                              dp_len = wifi_data_process_buf[offset + DATA_START];
                              dp_len <<= 8;
                              dp_len |= wifi_data_process_buf[offset + DATA_START + 1];
                              dp_len <<= 8;
                              dp_len |= wifi_data_process_buf[offset + DATA_START + 2];
                              dp_len <<= 8;
                              dp_len |= wifi_data_process_buf[offset + DATA_START + 3];
                    
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/21/2020 10:49:10 PAGE 12  

                              file_data_addr = (unsigned char *)wifi_data_process_buf;
                              file_data_addr += (offset + DATA_START + 4);
                    
                              if((total_len == 4) && (dp_len == file_download_size)) {
                                  //æœ€åä¸€åŒ…
                                  ret = file_download_handle(file_data_addr,dp_len,0);
                                  file_download_flag = 0;
                              }
                              else if((total_len - 4) <= file_package_size) {
                                  ret = file_download_handle(file_data_addr,dp_len,total_len - 4);
                              }else {
                                  file_download_flag = 0;
                                  ret = ERROR;
                              }
                    
                              if(ret == SUCCESS) {
                                  wifi_uart_write_frame(FILE_DOWNLOAD_TRANS_CMD, MCU_TX_VER, 0);
                              }
                          }
                      break;
              #endif
 679   2              
 680   2      #ifdef MODULE_EXPANDING_SERVICE_ENABLE
                      case MODULE_EXTEND_FUN_CMD:                             //æ¨¡å—æ‹“å±•æœåŠ¡
                          total_len = (wifi_data_process_buf[offset + LENGTH_HIGH] << 8) | wifi_data_process_buf[offset 
             -+ LENGTH_LOW];
                          open_module_time_serve_result((unsigned char *)(wifi_data_process_buf + offset + DATA_START), 
             -total_len);
                      break;
              #endif
 686   2      
 687   2      #ifdef BLE_RELATED_FUNCTION_ENABLE
                      case BLE_TEST_CMD:                                      //è“ç‰™åŠŸèƒ½æ€§æµ‹è¯•ï¼ˆæ‰«ææŒ‡å®šè“ç
             -‰™ä¿¡æ ‡ï¼‰
                          total_len = (wifi_data_process_buf[offset + LENGTH_HIGH] << 8) | wifi_data_process_buf[offset 
             -+ LENGTH_LOW];
                          BLE_test_result((unsigned char *)(wifi_data_process_buf + offset + DATA_START), total_len);
                      break;
              #endif
 693   2      
 694   2                  
 695   2      #ifdef VOICE_MODULE_PROTOCOL_ENABLE
                      case GET_VOICE_STATE_CMD:                               //è·å–è¯­éŸ³çŠ¶æ€ç 
                          result = wifi_data_process_buf[offset + DATA_START];
                          get_voice_state_result(result);
                      break;
                      case MIC_SILENCE_CMD:                                   //MICé™éŸ³è®¾ç½®
                          result = wifi_data_process_buf[offset + DATA_START];
                          set_voice_MIC_silence_result(result);
                      break;
                      case SET_SPEAKER_VOLUME_CMD:                            //speakeréŸ³é‡è®¾ç½®
                          result = wifi_data_process_buf[offset + DATA_START];
                          set_speaker_voice_result(result);
                      break;
                      case VOICE_TEST_CMD:                                    //è¯­éŸ³æ¨¡ç»„éŸ³é¢‘äº§æµ‹
                          result = wifi_data_process_buf[offset + DATA_START];
                          voice_test_result(result);
                      break;
                      case VOICE_AWAKEN_TEST_CMD:                             //è¯­éŸ³æ¨¡ç»„å”¤é†’äº§æµ‹
                          result = wifi_data_process_buf[offset + DATA_START];
                          voice_awaken_test_result(result);
                      break;
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/21/2020 10:49:10 PAGE 13  

                      case VOICE_EXTEND_FUN_CMD:                              //è¯­éŸ³æ¨¡ç»„æ‰©å±•åŠŸèƒ½
                          total_len = (wifi_data_process_buf[offset + LENGTH_HIGH] << 8) | wifi_data_process_buf[offset 
             -+ LENGTH_LOW];
                          voice_module_extend_fun((unsigned char *)(wifi_data_process_buf + offset + DATA_START), total_
             -len);
                      break;
              #endif
 721   2              
 722   2      
 723   2              default:break;
 724   2          }
 725   1      }
 726          
 727          /**
 728           * @brief  åˆ¤æ–­ä¸²å£æ¥æ”¶ç¼“å­˜ä¸­æ˜¯å¦æœ‰æ•°æ®
 729           * @param  Null
 730           * @return æ˜¯å¦æœ‰æ•°æ®
 731           */
 732          unsigned char with_data_rxbuff(void)
 733          {
 734   1          if(rx_buf_in != rx_buf_out)
 735   1              return 1;
 736   1          else
 737   1              return 0;
 738   1      }
 739          
 740          /**
 741           * @brief  è¯»å–é˜Ÿåˆ—1å­—èŠ‚æ•°æ®
 742           * @param  Null
 743           * @return Read the data
 744           */
 745          unsigned char take_byte_rxbuff(void)
 746          {
 747   1          unsigned char value;
 748   1          
 749   1          if(rx_buf_out != rx_buf_in) {
 750   2              //æœ‰æ•°æ®
 751   2              if(rx_buf_out >= (unsigned char *)(wifi_uart_rx_buf + sizeof(wifi_uart_rx_buf))) {
 752   3                  //æ•°æ®å·²ç»åˆ°æœ«å°¾
 753   3                  rx_buf_out = (unsigned char *)(wifi_uart_rx_buf);
 754   3              }
 755   2              
 756   2              value = *rx_buf_out ++;   
 757   2          }
 758   1          
 759   1          return value;
 760   1      }
 761          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1033    ----
   CONSTANT SIZE    =     59    ----
   XDATA SIZE       =    113    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      47
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
