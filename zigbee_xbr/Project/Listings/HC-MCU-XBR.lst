C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE HC_MCU_XBR
OBJECT MODULE PLACED IN .\Objects\HC-MCU-XBR.obj
COMPILER INVOKED BY: d:\cccc2020\TOOL\Keil\C51\BIN\C51.EXE ..\User\HC-MCU-XBR.c OPTIMIZE(SIZE) BROWSE DEBUG OBJECTEXTEND
                    - PRINT(.\Listings\HC-MCU-XBR.lst) TABS(2) OBJECT(.\Objects\HC-MCU-XBR.obj)

line level    source

   1          #define ALLOCATE_EXTERN
   2          #include "HC89S003F4.h"
   3          //#include "Mcu_api.h"
   4          #include "wifi.h"
   5          
   6          #define V12 //Ó²¼ş°å¿¨µÄ°æ±¾
   7          //#define V10
   8          
   9          //#define  VERSION  0X21
  10          
  11          #define TH_LOW 30000
  12          #define TH_HIGH 4000000
  13          
  14          #define TH_DEF 40000
  15          
  16          //ÔÊĞíÔëÉùÖµÆ«²î·¶Î§
  17          #define MAX_DELTA0 20000 //×î´óÆ«²îµÍÖµ
  18          #define MAX_DELTA1 60000 //×î´óÆ«²î¸ßÖµ
  19          
  20          #define MAX_DELAY 1800
  21          //×î´óÑÓÊ±ÃëÊı
  22          
  23          //¸Ğ¹âÃÅÏŞ-30¶ÔÓ¦8LUX×óÓÒµÄADÖµ,ÉèÖÃÎª255±íÊ¾²»¼ì²â¸Ğ¹â
  24          #define LIGHT_TH0 255
  25          //30
  26          
  27          //Ò»¸ö¼ì²âÖÜÆÚÎª0.25Ãë
  28          //#define DELAY_NUM 20
  29          
  30          //#define LIGHT_ON P0_6=0
  31          //#define LIGHT_OFF P0_6=1
  32          
  33          //void Delay_2us(u16 Cnt);    //ÑÓÊ±º¯Êı
  34          
  35          // bit Timer1_FLAG;
  36          // bit Time_10mS_FLAG;
  37          // bit Time_100mS_FLAG;
  38          // bit Time_200mS_FLAG;
  39          // bit Time_500mS_FLAG;
  40          // bit Time_1S_FLAG;
  41          // bit Time_10S_FLAG;
  42          // bit Time_1Min_FLAG;
  43          // bit Time_1H_FLAG;
  44          
  45          volatile ulong Timer_Counter = 0;
  46          
  47          //u8 Uart1_RX_Buff[10] = {0};          //ÓÃÓÚ´æ·ÅUART1½ÓÊÕÊı¾İ
  48          //u8 Uart1_RX_Cnt = 0;                 //UART1½ÓÊÕ¼ÆÊı
  49          //u8 Uart1_TX_Buff[20] = {0};          //ÓÃÓÚ´æ·ÅUART1·¢ËÍÊı¾İ
  50          //u8 Uart1_TX_Cnt = 0;                 //UART1·¢ËÍ¼ÆÊı
  51          
  52          // u16 AN1_Data = 0;
  53          // u16 AN7_Data = 0;
  54          // u8 Uart_Cnt = 0;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 2   

  55          
  56          u8 xdata SUM1_counter = 0; //???
  57          u8 xdata SUM0_num = 12;    //???
  58          u8 xdata SUM1_num = 64;    //???
  59          ulong xdata SUM01;
  60          //ulong xdata SUM2;      //µ÷ÊÔÓÃ
  61          ulong xdata SUM10 = 0;     //SUM1ÖµµÄ¼¸´ÎÆ½¾ùÖµ£¬Ê±¼äÉÏµÄÖÍºóÖµ
  62          ulong xdata SUM0 = 0;    //
  63          ulong xdata SUM1 = 0;    //Æ½¾ù¾ø¶ÔÀë²îµÄÀÛ¼ÓºÏµÄË²Ê±Öµ
  64          ulong xdata ALL_SUM1 = 0;  //SUM1µÄÀÛ¼ÓÖµ
  65          ulong xdata SUM16 = 0;     //2^16´ÎµÄÀÛ¼ÆÖµ±äÁ¿
  66          ulong xdata SUM = 0;     //an1µÄrawÀÛ¼ÓÖµ
  67          u16 xdata start_times = 1; //???
  68          u16 xdata times = 0;     //Ö÷Ñ­»·´ÎÊı
  69          ulong xdata TH;        //ÉèÖÃÎó²îãĞÖµ£¬¿ÉÓÉAPPÉèÖÃµÄ¸ĞÓ¦Ç¿¶È×ª»»
  70          ulong xdata MAX_DELTA; //×î´óÆ«²îÖµ
  71          u8 xdata alarm_times = 0;
  72          u8 xdata stop_times = 0; //???
  73          
  74          uint xdata LIGHT = 0;   //°éÁÁµÆÃëµÄ¼ÆÊıÆ÷
  75          uint xdata LIGHT_off = 0; //ÎŞÈËÃğµÆµÄ·ÖÖÓ¼ÆÊıÆ÷
  76          uint xdata average;     //an1µÄrawÆ½¾ùÖµ
  77          
  78          u8 xdata light_ad;  //¹âÃôÊµÊ±Öµraw
  79          u8 xdata light_ad0; //¹âÃô³õÊ¼Ë²Ê±Öµraw
  80          
  81          u8 xdata check_sum, send_byte;
  82          u8 xdata check_light_times = 8;  //ÓÃÓÚ¹âÃô¼ì²éµÄ¼ÆÊıÆ÷
  83          u8 xdata calc_average_times = 0; //ÓÃÓÚ¼ÆËãÆ½¾ùÖµµÄ¼ÆÊıÆ÷
  84          u8 xdata LIGHT_TH;
  85          u16 xdata DELAY_NUM;
  86          u8 xdata lowlightDELAY_NUM;
  87          u8 xdata RXnum = 0;
  88          u8 while_1flag = 0;     //°éÁÁÍê³É±êÖ¾
  89          u8 while_2flag = 0;     //???
  90          u8 xdata SWITCHflag = 0;  //ÔİÊ±Ã»ÓĞÊ¹ÓÃ
  91          u8 xdata SWITCHflag2 = 0; //µÆ¿ª¹ØµÄ±äÁ¿£¬¿ÉÓÉAPPÉèÖÃ
  92          u8 xdata SWITCHfXBR = 1;  //À×´ï¸ĞÓ¦¿ª¹ØµÄ±äÁ¿£¬¿ÉÓÉAPPÉèÖÃ
  93          u8 xdata lightvalue = 10; //ÁÁ¶ÈÖµ£¬¿ÉÓÉAPPÉèÖÃ
  94          u8 xdata switchcnt = 0;
  95          u8 xdata slowchcnt = 10;          //ÁÁ¶È½¥Á¿Öµ
  96          u8 xdata resetbtcnt = 0;          //ÎªÖØÖÃÀ¶ÑÀÄ£¿éÉèÖÃµÄ¼ÆÊıÆ÷
  97          u8 xdata XRBoffbrightvalue = 0;       //µ±¹Ø±ÕÀ×´ïÊ±£¬APPÉèÖÃµÄÁÁ¶ÈÖµ
  98          volatile u16 xdata lowlight1mincount = 0; //timerµÄ¼ÆÊıÆ÷1ms×Ô¼Ó
  99          volatile u8 xdata lowlight1minflag = 0;   //timerµÄ·ÖÖÓ±êÖ¾
 100          volatile u16 idata light1scount = 0;    //timerµÄ¼ÆÊıÆ÷1ms×Ô¼Ó
 101          volatile u16 idata light1sflag = 0;     //timerµÄÃë±êÖ¾
 102          u8 xdata addr = 0;
 103          u8 xdata devgroup = 0;
 104          u8 xdata addrend = 0;
 105          u16 idata groupaddr[8] = {0};
 106          u8 idata check_group_flag = 0;  //¼ì²éÈº×é±êÖ¾
 107          u8 idata check_group_count = 0; //¼ì²éÈº×é¼ÆÊıÆ÷
 108          u8 idata Linkage_flag = 0;
 109          u8 idata Light_on_flag = 0;
 110          u8 idata Light_on_flagpre = 0;
 111          
 112          /*
 113             u8 idata groupaddr2 = 0;
 114             u8 idata groupaddr3 = 0;
 115             u8 idata groupaddr4 = 0;
 116             u8 idata groupaddr5 = 0;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 3   

 117             u8 idata groupaddr6 = 0;
 118             u8 idata groupaddr7 = 0;
 119             u8 idata groupaddr8 = 0;
 120             */
 121          unsigned char PWM3init(unsigned char ab);
 122          void Flash_EraseBlock(unsigned int fui_Address); //ÉÈÇø²Á³ı
 123          //void FLASH_WriteData(unsigned char fui_Address, unsigned int fuc_SaveData);//Ğ´ÈëÒ»¸öÊı¾İ
 124          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address);
 125          //void Flash_WriteArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr);//Ğ´È
             -ëÈÎÒâ³¤¶ÈÊı¾İ
 126          void Flash_ReadArr(unsigned int fui_Address, unsigned char fuc_Length, unsigned char *fucp_SaveArr); //¶ÁÈ
             -¡ÈÎÒâ³¤¶ÈÊı¾İ
 127          
 128          //unsigned char guc_Write_a[5] = {0}; //Ğ´ÈëÊı¾İ
 129          unsigned char xdata guc_Read_a[10] = {0x00}; //ÓÃÓÚ´æ·Å¶ÁÈ¡µÄÊı¾İ
 130          unsigned char xdata guc_Read_a1[1] = {0x00}; //ÓÃÓÚ´æ·Å¶ÁÈ¡µÄÊı¾İ
 131          // unsigned char guc_Uartflag = 0;            //·¢ËÍ±êÖ¾Î»
 132          // unsigned char guc_Uartcnt = 0;           //·¢ËÍ¼ÆÊı
 133          // unsigned char guc_Uartbuf_a[2] = {0x00}; //»º´æÊı×é
 134          
 135          void Flash_ReadArr(unsigned int fui_Address, unsigned char fuc_Length, unsigned char *fucp_SaveArr)
 136          {
 137   1        while (fuc_Length--)
 138   1          *(fucp_SaveArr++) = *((unsigned char code *)(fui_Address++)); //¶ÁÈ¡Êı¾İ
 139   1      }
 140          
 141          void Delay_us(uint q)
 142          {
 143   1        uint j;
 144   1        for (j = 0; j < q; j++)
 145   1        {
 146   2          ;
 147   2        }
 148   1      }
 149          
 150          void Delay_ms(uint t)
 151          {
 152   1        Timer_Counter = 0;
 153   1        while (Timer_Counter < t)
 154   1        {
 155   2          WDTC |= 0x10; //Çå¿´ÃÅ¹·
 156   2        }
 157   1      }
 158          
 159          void Delay_us_1(uint q1)
 160          {
 161   1        uint j;
 162   1        for (j = 0; j < q1; j++)
 163   1        {
 164   2          ;
 165   2        }
 166   1      }
 167          
 168          // void Delay_ms(uint t)
 169          // {
 170          //  for(;t>0;t--)
 171          //  {
 172          //    Delay_us_1(1000);
 173          //    WDTC |= 0x10;   //Çå¿´ÃÅ¹·
 174          //  }
 175          // }
 176          
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 4   

 177          /***************************************************************************************
 178            * @ËµÃ÷   ÏµÍ³³õÊ¼»¯º¯Êı
 179            * @²ÎÊı   ÎŞ
 180            * @·µ»ØÖµ ÎŞ
 181            * @×¢     ÎŞ
 182          ***************************************************************************************/
 183          void InitSYS()
 184          {
 185   1        /********************************ÏµÍ³ÆµÂÊ³õÊ¼»¯***************************************/
 186   1      
 187   1        CLKSWR = 0x51;   //Ñ¡ÔñÄÚ²¿¸ßÆµRCÎªÏµÍ³Ê±ÖÓ£¬ÄÚ²¿¸ßÆµRC 2·ÖÆµ£¬Fosc=16MHz
 188   1        CLKDIV = 0x01;   //Fosc 1·ÖÆµµÃµ½Fcpu£¬Fcpu=16MHz
 189   1        FREQ_CLK = 0x10; //IAPÆµÂÊ
 190   1      
 191   1        /**********************************µÍÑ¹¸´Î»³õÊ¼»¯**************************************/
 192   1      
 193   1        //  BORC = 0xC0;                       //Ê¹ÄÜµÍÑ¹¸´Î»1.8V£¬´øÏû¶¶Ê¹ÄÜ
 194   1        //  BORDBC = 0x01;                     //Ïû¶¶Ê±¼äBORDBC*8TCPU+2TCPU
 195   1      
 196   1        /***********************************¿´ÃÅ¿Ú³õÊ¼»¯***************************************/
 197   1        WDTC = 0x5F;   //ÔÊĞíWDT¸´Î»£¬¿ÕÏĞÄ£Ê½ÏÂ½ûÖ¹WDT£¬Ñ¡Ôñ1024·ÖÆµ£¨ÄÚ²¿µÍÆµÊ±ÖÓ44K£©
 198   1        WDTCCR = 0X20; //0X20/44  =0.73Ãë           //0xFF;  //Òç³öÊ±¼äÔ¼6Ãë
 199   1                 //Òç³ö¼ÆËãÊ±¼ä=£¨WDT·ÖÆµÏµÊı*£¨WDTCCR+1£©£©/ÄÚ²¿µÍÆµRCÆµÂÊ
 200   1      }
 201          
 202          /***************************************************************************************
 203            * @ËµÃ÷   ¶¨Ê±Æ÷³õÊ¼»¯º¯Êı
 204            * @²ÎÊı   ÎŞ
 205            * @·µ»ØÖµ ÎŞ
 206            * @×¢     ÎŞ
 207          ***************************************************************************************/
 208          void Timer_Init()
 209          {
 210   1        /**********************************TIM1ÅäÖÃ³õÊ¼»¯**************************************/
 211   1        TCON1 = 0x00; //T1¶¨Ê±Æ÷Ê±ÖÓÎªFosc
 212   1        TMOD = 0x01;  //T1-16Î»ÖØ×°ÔØ¶¨Ê±Æ÷/¼ÆÊıÆ÷,T0-16Î»¶¨Ê±Æ÷
 213   1      
 214   1        //Tim1¼ÆËãÊ±¼ä  = (65536 - 0xFACB) * (1 / (Fosc /Timer·ÖÆµÏµÊı))
 215   1        //        = 1333 / (16000000 / 12)
 216   1        //        = 1 ms
 217   1      
 218   1        //T1¶¨Ê±1ms
 219   1        //·´ÍÆ³õÖµ  = 65536 - ((1/1000) / (1/(Fosc / Timer·ÖÆµÏµÊı)))
 220   1        //        = 65536 - ((1/1000) / (1/(16000000 / 12)))
 221   1        //      = 65536 - 1333
 222   1        //      = 0xFACB
 223   1      
 224   1        TH1 = 0xFA;
 225   1        TL1 = 0xCB;   //T1¶¨Ê±1ms
 226   1        IE |= 0x08;   //´ò¿ªT1ÖĞ¶Ï
 227   1        TCON |= 0x40; //Ê¹ÄÜT1
 228   1      
 229   1        TH0 = 0xCB;
 230   1        TL0 = 0xEB; //T0¶¨Ê±Ê±¼ä10ms
 231   1      
 232   1        TCON |= 0x10; //Ê¹ÄÜT0
 233   1      }
 234          
 235          /***************************************************************************************
 236            * @ËµÃ÷   UART1³õÊ¼»¯º¯Êı
 237            * @²ÎÊı   ÎŞ
 238            * @·µ»ØÖµ ÎŞ
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 5   

 239            * @×¢     ÎŞ
 240          ***************************************************************************************/
 241          void UART1_Init()
 242          {
 243   1        /**********************************UARTÅäÖÃ³õÊ¼»¯**************************************/
 244   1        P2M0 = P2M0 & 0xF0 | 0x08; //P20ÉèÖÃÎªÍÆÍìÊä³ö
 245   1        P0M2 = P0M2 & 0xF0 | 0x02; //P04ÉèÖÃÎªÉÏÀ­ÊäÈë
 246   1        P0_4 = 1;
 247   1        TXD_MAP = 0x20; //TXDÓ³ÉäP20
 248   1        RXD_MAP = 0x04; //RXDÓ³ÉäP04
 249   1        T4CON = 0x06; //T4¹¤×÷Ä£Ê½£ºUART1²¨ÌØÂÊ·¢ÉúÆ÷
 250   1      
 251   1        //²¨ÌØÂÊ¼ÆËã
 252   1        //²¨ÌØÂÊ = 1/16 * (T4Ê±ÖÓÔ´ÆµÂÊ / ¶¨Ê±Æ÷4Ô¤·ÖÆµ±È) / (65536 - 0xFF98)
 253   1        //       = 1/16 * ((16000000 / 1) / 104)
 254   1        //     = 9615.38(Îó²î0.16%)
 255   1      
 256   1        //²¨ÌØÂÊ9600
 257   1        //·´ÍÆ³õÖµ = (65536 - ((T4Ê±ÖÓÔ´ÆµÂÊ / ¶¨Ê±Æ÷4Ô¤·ÖÆµ±È) * (1 / 16)) / ²¨ÌØÂÊ)
 258   1        //       = (65536 - (16000000 * (1 / 16) / 9600))
 259   1        //       = (65536 - 104.167)
 260   1        //         = FF98
 261   1        //0xFF98->9600
 262   1        //0xFFCC->19200
 263   1        //0xFFEF->57600
 264   1      
 265   1        TH4 = 0xFF;
 266   1        TL4 = 0x98;   //²¨ÌØÂÊ9600    //0xEE;       //²¨ÌØÂÊ56000
 267   1        SCON2 = 0x02; //8Î»UART£¬²¨ÌØÂÊ¿É±ä
 268   1        SCON = 0x10;  //ÔÊĞí´®ĞĞ½ÓÊÕ
 269   1        IE |= 0X10;   //Ê¹ÄÜ´®¿ÚÖĞ¶Ï
 270   1                //EA = 1;                              //Ê¹ÄÜ×ÜÖĞ¶Ï
 271   1      }
 272          
 273          /***************************************************************************************
 274            * @ËµÃ÷   ADC³õÊ¼»¯º¯Êı
 275            * @²ÎÊı   ÎŞ
 276            * @·µ»ØÖµ ÎŞ
 277            * @×¢     ÎŞ
 278          ***************************************************************************************/
 279          void ADC_Init()
 280          {
 281   1      
 282   1        ADCC0 |= 0x03; //²Î¿¼Ô´ÎªÄÚ²¿2V
 283   1        ADCC0 |= 0x80; //´ò¿ªADC×ª»»µçÔ´
 284   1        Delay_us(20);  //ÑÓÊ±20us£¬È·±£ADCÏµÍ³ÎÈ¶¨
 285   1        ADCC1 = 0x01;  //Ñ¡ÔñÍâ²¿Í¨µÀ1
 286   1        ADCC2 = 0x4B;  //8·ÖÆµ    //×ª»»½á¹û12Î»Êı¾İ£¬Êı¾İÓÒ¶ÔÆë£¬ADCÊ±ÖÓ16·ÖÆµ-1MHZ//0X4B-8·ÖÆµ//0X49-4·ÖÆµ
 287   1      }
 288          
 289          /***************************************************************************************
 290            * @ËµÃ÷   IO¿Ú³õÊ¼»¯º¯Êı
 291            * @²ÎÊı   ÎŞ
 292            * @·µ»ØÖµ ÎŞ
 293            * @×¢     ÎŞ
 294          ***************************************************************************************/
 295          void GPIO_Init()
 296          {
 297   1        //P0M0·Ö¸ß4Î»ÓëµÍ4Î»£¬µÍ4Î»¿ØÖÆP00ÊäÈëÊä³ö£¬¸ß4Î»¿ØÖÆP01ÊäÈëÊä³ö£¬ÆäËûÒÔ´ËÀàÍÆ
 298   1        //P0M1¸ß4¿ØÖÆP03£¬µÍ4¿ØÖÆP02
 299   1        //P1M2¸ß4¿ØÖÆP15£¬µÍ4¿ØÖÆP14
 300   1      
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 6   

 301   1        //  P0M0 = P0M0&0xF0|0x08;          //P00ÉèÖÃÎªÍÆÍìÊä³ö
 302   1        //  P0M0 = P0M0&0x0F|0x30;          //P01ÉèÖÃÎªÄ£ÄâÊäÈë
 303   1        //  P0M3 = P0M3&0x0F|0x30;          //P07ÉèÖÃÎªÄ£ÄâÊäÈë
 304   1        //  P0M3 = P0M3&0xF0|0x08;          //P06ÉèÖÃÎªÍÆÍìÊä³ö
 305   1      
 306   1      #ifdef V11
              
                P0M0 = P0M0 & 0xF0 | 0x08; //P00ÉèÖÃÎªÍÆÍìÊä³ö
              
                P0M0 = P0M0 & 0x0F | 0x30; //P01ÉèÖÃÎªÄ£ÄâÊäÈë
                //P0M3 = P0M3&0x0F|0x30;          //P07ÉèÖÃÎªÄ£ÄâÊäÈë
                //  P0M0 = P0M0&0x0F|0x80;          //P01ÉèÖÃÎªÍÆÍìÊä³ö
              
                P0M2 = P0M2 & 0x0F | 0x80; //P05ÉèÖÃÎªÍÆÍìÊä³ö
              
                P0M3 = P0M3 & 0xF0 | 0x03; //P06ÉèÖÃÎªÄ£ÄâÊäÈë  //|0x08;          //P06ÉèÖÃÎªÍÆÍìÊä³ö
              
                P0M3 = P0M3 & 0x0F | 0x20; //P07ÉèÖÃÎªÉÏÀ­ÊäÈë
              
              #endif
 321   1      
 322   1      #ifdef V10
              
                P0M0 = P0M0 & 0xF0 | 0x08; //P00
              
                P0M0 = P0M0 & 0x0F | 0x30; //P01
                P0M3 = P0M3 & 0x0F | 0x30; //P07
                               // P0M0 = P0M0&0x0F|0x80;          //P01
              
                P0M3 = P0M3 & 0xF0 | 0x08; //P06
              
              #endif
 333   1      
 334   1      #ifdef V12
 335   1      
 336   1        P1M0 = P1M0 & 0xF0 | 0x08; //P10ÉèÖÃÎªÍÆÍìÊä³ö
 337   1      
 338   1        P0M0 = P0M0 & 0x0F | 0x30; //P01ÉèÖÃÎªÄ£ÄâÊäÈë
 339   1      
 340   1        P2M1 = P2M1 & 0xF0 | 0x03; //P22ÉèÖÃÎªÄ£ÄâÊäÈë
 341   1      
 342   1        //P0M3 = P0M3&0x0F|0x30;          //P07ÉèÖÃÎªÄ£ÄâÊäÈë
 343   1        //  P0M0 = P0M0&0x0F|0x80;          //P01ÉèÖÃÎªÍÆÍìÊä³ö
 344   1      
 345   1        //P0M2 = P0M2&0x0F|0x80;          //P05ÉèÖÃÎªÍÆÍìÊä³ö
 346   1      
 347   1        //P0M3 = P0M3&0xF0|0x03;      //P06ÉèÖÃÎªÄ£ÄâÊäÈë  //|0x08;         //P06ÉèÖÃÎªÍÆÍìÊä³ö
 348   1      
 349   1        //  P0M3 = P0M3&0x0F|0x20;          //P07ÉèÖÃÎªÉÏÀ­ÊäÈë
 350   1      
 351   1      #endif
 352   1      }
 353          
 354          // u16 Read_ADC(u8 Channel)
 355          // {
 356          //  u16 ADC_Temp;
 357          //  ADCC1 = Channel;              //Ñ¡ÔñÍâ²¿Í¨µÀ1
 358          //   ADCC0 |= 0x40;         //Æô¶¯ADC×ª»»
 359          //  while(!(ADCC0&0x20));   //µÈ´ıADC×ª»»½áÊø
 360          //  ADCC0 &=~ 0x20;         //Çå³ı±êÖ¾Î»
 361          //  ADC_Temp = ADCR;        //»ñÈ¡ADCµÄÖµ
 362          //  return ADC_Temp;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 7   

 363          // }
 364          
 365          /***************************************************************************************
 366            * @ËµÃ÷   ÏµÍ³Ê±ÖÓ¼ÆÊıº¯Êı
 367            * @²ÎÊı   ÎŞ
 368            * @·µ»ØÖµ ÎŞ
 369            * @×¢     ÎŞ
 370          ***************************************************************************************/
 371          /*
 372          void System_Time_Cnt(void)
 373          {
 374              static u32 Timer1Count1 = 0;
 375              static u8 Timer1Count2 = 0;
 376              u32 Tampe = 1;
 377              if(Timer1_FLAG)              //1ms
 378              {
 379                  Timer1_FLAG = 0;
 380                  Timer1Count1 ++;
 381                  Tampe = Timer1Count1 % 10;
 382                  if(Tampe == 0)
 383                      Time_10mS_FLAG = 1;
 384                  Tampe = Timer1Count1 % 100;
 385                  if(Tampe == 0)
 386                      Time_100mS_FLAG = 1;
 387                  Tampe = Timer1Count1 % 200;
 388                  if(Tampe == 0)
 389                      Time_200mS_FLAG = 1;
 390                  Tampe = Timer1Count1 % 500;
 391                  if(Tampe == 0)
 392                      Time_500mS_FLAG = 1;
 393                  Tampe = Timer1Count1 % 1000;
 394                  if(Tampe == 0)
 395                      Time_1S_FLAG = 1;
 396                  Tampe = Timer1Count1 % 10000;
 397                  if(Tampe == 0)
 398                  {
 399                      Time_10S_FLAG = 1;
 400                      Timer1Count1 = 0;
 401                      Timer1Count2 ++;
 402                      Tampe = Timer1Count2 % 6;
 403                      if(Tampe == 0)
 404                          Time_1Min_FLAG = 1;
 405                      Tampe = Timer1Count2 % 60;
 406                      if(Tampe == 0)
 407                      {
 408                          Time_1H_FLAG = 1;
 409                          Timer1Count2 = 0;
 410                      }
 411                  }
 412              }
 413          }
 414          */
 415          
 416          /***************************************************************************************
 417            * @ËµÃ÷   ÏµÍ³ÈÎÎñ´¦Àíº¯Êı
 418            * @²ÎÊı   ÎŞ
 419            * @·µ»ØÖµ ÎŞ
 420            * @×¢     ÎŞ
 421          ***************************************************************************************/
 422          
 423          /*
 424          void System_Task(void)
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 8   

 425          {
 426              u8 temp;
 427              if(Time_10mS_FLAG)
 428              {
 429                  Time_10mS_FLAG = 0;
 430                  //User TASK
 431                  
 432                  
 433                  //User TASK
 434                  if(Time_100mS_FLAG)
 435                  {
 436                      Time_100mS_FLAG = 0;
 437                      //User TASK
 438          
 439                  
 440                  
 441                      //User TASK
 442                  }
 443                  if(Time_200mS_FLAG)
 444                  {
 445                      Time_200mS_FLAG = 0;
 446                      //User TASK
 447          
 448                  
 449                  
 450                      //User TASK
 451                  }
 452                  if(Time_500mS_FLAG)
 453                  {
 454                      Time_500mS_FLAG = 0;
 455                      //User TASK
 456                      AN1_Data = Read_ADC(0x01);
 457                    
 458                      //User TASK
 459                  }
 460                   if(Time_1S_FLAG)
 461                  {
 462                      Time_1S_FLAG = 0;
 463                      //User TASK
 464          
 465                      temp = 0xFF & (AN1_Data >> 8);
 466                      SBUF = temp;
 467                      while(!(SCON & 0x02));
 468                      SCON &=~ 0x02;                 //Çå³ı·¢ËÍÖĞ¶Ï±êÖ¾Î»
 469                      temp = 0xFF & AN1_Data;
 470                      SBUF = temp;
 471                      while(!(SCON & 0x02));
 472                      SCON &=~ 0x02;                 //Çå³ı·¢ËÍÖĞ¶Ï±êÖ¾Î»
 473                      P0_0 =~ P0_0; 
 474                      //User TASK
 475                      
 476                  }
 477                  if(Time_10S_FLAG)
 478                  {
 479                      Time_10S_FLAG = 0;
 480                      //User TASK
 481                      
 482          
 483                      //User TASK
 484                  }
 485                  if(Time_1Min_FLAG)
 486                  {
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 9   

 487                      Time_1Min_FLAG = 0;
 488                      //User TASK
 489                  
 490                  
 491                  
 492                      //User TASK
 493                  }
 494                  if(Time_1H_FLAG)
 495                  {
 496                      Time_1H_FLAG = 0;
 497                      //User TASK
 498                  
 499                  
 500                  
 501                      //User TASK
 502                  }
 503              }
 504          }
 505          */
 506          
 507          void send_data(u8 d)
 508          {
 509   1        SBUF = d;
 510   1        while (!(SCON & 0x02))
 511   1          ;
 512   1        SCON &= ~0x02;
 513   1      }
 514          
 515          //return 8-bit adc raw
 516          uchar read_ad(uchar ch)
 517          {
 518   1        u8 i;
 519   1        uint ad_sum;
 520   1      
 521   1        //  switch (ch)
 522   1        //  {
 523   1        //    case 3:
 524   1        //      ADC_P16_AN3;
 525   1        //      break;
 526   1        //    case 4:
 527   1        //      ADC_P15_AN4;
 528   1        //      break;
 529   1        //    case 5:
 530   1        //      ADC_P14_AN5;
 531   1        //      break;
 532   1        //  }
 533   1      
 534   1        //  if(ch==3)
 535   1        //  {
 536   1        //    ADC_P16_AN3;
 537   1        //  }
 538   1        //  else if(ch==4)
 539   1        //  {
 540   1        //    ADC_P15_AN4;
 541   1        //  }
 542   1      
 543   1        ADCC1 = ch;    //Ñ¡ÔñÍâ²¿Í¨µÀ
 544   1        ADCC0 |= 0x40; //Æô¶¯ADC×ª»»
 545   1        while (!(ADCC0 & 0x20))
 546   1          ;     //µÈ´ıADC×ª»»½áÊø
 547   1        ADCC0 &= ~0x20; //Çå³ı±êÖ¾Î»
 548   1      
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 10  

 549   1        //ADC_Temp = ADCR;        //»ñÈ¡ADCµÄÖµ
 550   1      
 551   1        //  delay_ms(1);
 552   1        //
 553   1        //  ADC_TG;
 554   1        Delay_us(100);
 555   1      
 556   1        ad_sum = 0;
 557   1        //ADC_INT_IF_CLR; //ÇåÖĞ¶Ï±êÖ¾Î»
 558   1      
 559   1        for (i = 0; i < 16; i++)
 560   1        {
 561   2          //    ADC_TG;
 562   2          //    while(ADC_IF==0){};
 563   2          //    //adc_data = ADC_DATA_RD();
 564   2          //
 565   2          //    k=ADC_DH;
 566   2          //    k =k <<8;
 567   2          //    k+=ADC_DL;
 568   2          //
 569   2          //    ADC_INT_IF_CLR; //ÇåÖĞ¶Ï±êÖ¾Î»
 570   2          //    ad_sum+=k;
 571   2      
 572   2          ADCC0 |= 0x40; //Æô¶¯ADC×ª»»
 573   2          while (!(ADCC0 & 0x20))
 574   2            ;     //µÈ´ıADC×ª»»½áÊø
 575   2          ADCC0 &= ~0x20; //Çå³ı±êÖ¾Î»
 576   2          ad_sum += ADCR; //»ñÈ¡ADCµÄÖµ
 577   2      
 578   2          Delay_us(20);
 579   2        }
 580   1      
 581   1        //ADC_P14_AN5;
 582   1        ADCC1 = 1; //ÇĞ»»µ½an1
 583   1        i = ad_sum >> 8;
 584   1      
 585   1        Delay_us(100);
 586   1        return (i);
 587   1      }
 588          
 589          void set_var(void)
 590          {
 591   1      
 592   1        Flash_ReadArr(0X2f00, 10, guc_Read_a); //¶ÁÈ¡µØÖ·0x2F00ËùÔÚÉÈÇø
 593   1      
 594   1        TH = guc_Read_a[0];
 595   1        TH <<= 8;
 596   1        TH += guc_Read_a[1];
 597   1        TH *= 1000;
 598   1        if (TH < TH_LOW || TH > TH_HIGH)
 599   1          TH = TH_DEF;
 600   1      
 601   1        LIGHT_TH = guc_Read_a[2];
 602   1      
 603   1        if (LIGHT_TH == 0)
 604   1          LIGHT_TH = LIGHT_TH0;
 605   1        else if (LIGHT_TH == 0XFE)
 606   1          LIGHT_TH = 255;
 607   1      
 608   1        DELAY_NUM = guc_Read_a[3];
 609   1        DELAY_NUM <<= 8;
 610   1        DELAY_NUM += guc_Read_a[4];
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 11  

 611   1        if (DELAY_NUM == 0 || DELAY_NUM > MAX_DELAY)
 612   1          DELAY_NUM = 5;
 613   1      
 614   1        //DELAY_NUM<<=2;
 615   1        lightvalue = guc_Read_a[5];
 616   1        //if(lightvalue>100)lightvalue=10;
 617   1        XRBoffbrightvalue = lightvalue;
 618   1      
 619   1        lowlightDELAY_NUM = guc_Read_a[6];
 620   1        if (lowlightDELAY_NUM == 0 || lowlightDELAY_NUM > 255)
 621   1          lowlightDELAY_NUM = 1;
 622   1      
 623   1        SWITCHfXBR = (guc_Read_a[7]) & 0x01;
 624   1        //  addr = guc_Read_a[7];
 625   1        //
 626   1        //  devgroup = guc_Read_a[8];
 627   1      
 628   1        //  addrend = guc_Read_a[9];
 629   1      
 630   1        Flash_ReadArr(0X2f80, 1, guc_Read_a1); //¶ÁÈ¡µØÖ·0x2F00ËùÔÚÉÈÇø
 631   1        resetbtcnt = guc_Read_a1[0];
 632   1      }
 633          
 634          void XBRHandle(void)
 635          {
 636   1        u16 k;
 637   1      
 638   1        if (while_1flag == 0)
 639   1        {
 640   2          //send_data(0x66);
 641   2          //        ADC_TG;
 642   2          //        while(ADC_IF==0){};
 643   2          //        //adc_data = ADC_DATA_RD();
 644   2          //
 645   2          //        k = ADC_DH<<8;
 646   2          //        //adc_data =adc_data <<8;
 647   2          //        k+= ADC_DL;
 648   2          //
 649   2          //        ADC_INT_IF_CLR; //ÇåÖĞ¶Ï±êÖ¾Î»
 650   2      
 651   2          ADCC0 |= 0x40; //Æô¶¯ADC×ª»»
 652   2          while (!(ADCC0 & 0x20))
 653   2            ;     //µÈ´ıADC×ª»»½áÊø
 654   2          ADCC0 &= ~0x20; //Çå³ı±êÖ¾Î»
 655   2          k = ADCR;   //»ñÈ¡ADCµÄÖµ
 656   2      
 657   2          times++;
 658   2      
 659   2          SUM += k;
 660   2      
 661   2          //¼ÆËãĞÅºÅÖµÓëÖ±Á÷µçÑ¹Æ«²îÖµ
 662   2          if (k > average)
 663   2          {
 664   3            k -= average;
 665   3          }
 666   2          else
 667   2          {
 668   3            k = average - k;
 669   3          }
 670   2          SUM1 += k;
 671   2      
 672   2          if ((times & 0x1ff) == 0) //Ã¿256´ÎÑ­»·¼ì²éÒ»´Î¹âÃô
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 12  

 673   2          {
 674   3            if (LIGHT > 0) //ÕıÔÚ°éÁÁµÄ¹ı³ÌÖĞ
 675   3            {
 676   4      
 677   4              //LIGHT++;
 678   4      
 679   4              if (slowchcnt < 100)
 680   4              {
 681   5                slowchcnt = slowchcnt + 2; //
 682   5                if (slowchcnt > 100)
 683   5                {
 684   6                  slowchcnt = 100;
 685   6                }
 686   5              }
 687   4              PWM3init(slowchcnt);
 688   4            }
 689   3            else if (LIGHT_off == 1) //else if((SWITCHflag2==0)&&(LIGHT_off ==1))
 690   3            {
 691   4              if (slowchcnt > lightvalue)
 692   4              {
 693   5                if (slowchcnt >= 2)
 694   5                  slowchcnt -= 2;
 695   5                if (slowchcnt < lightvalue)
 696   5                  slowchcnt = lightvalue;
 697   5              }
 698   4              PWM3init(slowchcnt);
 699   4            }
 700   3          }
 701   2      
 702   2          if (times >= 8192) //Ã¿250msµü´ú¼°ÅĞ¶ÏÒ»´Î
 703   2          {
 704   3      
 705   3            WDTC |= 0x10; //Çå¿´ÃÅ¹·
 706   3      
 707   3            times = 0;
 708   3      
 709   3            calc_average_times++;
 710   3      
 711   3            SUM16 += SUM;
 712   3      
 713   3            if (calc_average_times >= 8) //Ã¿2.5SÖØĞÂ¼ÆËãÒ»´ÎÖ±Á÷µçÑ¹Öµ
 714   3            {
 715   4              calc_average_times = 0;
 716   4      
 717   4              SUM16 >>= 16;
 718   4              //SUM16/=96000;//102400;
 719   4              average += SUM16;
 720   4              average /= 2;
 721   4              SUM16 = 0;
 722   4            }
 723   3      
 724   3            if (check_light_times < 8) //2s ¶ÁÈ¡Ò»´Î¸Ğ¹âADÖµ£¬Ë²Ê±¶Ô±ÈÖµÃ¿2s×óÓÒ¸üĞÂÒ»´Î
 725   3            {
 726   4              check_light_times++;
 727   4            }
 728   3            else
 729   3            {
 730   4              if (LIGHT == 0)
 731   4              {
 732   5                //light_ad=READ_LIGHT();
 733   5                light_ad = read_ad(10); //ÇĞ»»µ½an10
 734   5      
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 13  

 735   5                if ((light_ad <= (light_ad0 + 2)) && (light_ad0 <= (light_ad + 2)))
 736   5                  light_ad = light_ad0;
 737   5      
 738   5                light_ad0 = light_ad;
 739   5      
 740   5                check_light_times = 0;
 741   5              }
 742   4            }
 743   3      
 744   3            if (SUM0 == 0)
 745   3            {
 746   4              SUM0 = SUM1 + 5000;
 747   4              if (start_times == 0 && SUM0 > 1000000)
 748   4                SUM0 = 1000000; //Éè¼Æ³õÖµ
 749   4            }
 750   3      
 751   3            if (SUM1_counter == 0)
 752   3            {
 753   4              SUM10 = SUM1;
 754   4              MAX_DELTA = 1; //SUM10>>3;
 755   4                       //if(MAX_DELTA<MAX_DELTA0)MAX_DELTA=MAX_DELTA0;
 756   4            }
 757   3      
 758   3            if ((SUM10 < (SUM1 + MAX_DELTA)) && (SUM1 < (SUM10 + MAX_DELTA))) //???????????
 759   3            {
 760   4              SUM1_counter++;
 761   4              ALL_SUM1 += SUM1;
 762   4              SUM10 = ALL_SUM1 / SUM1_counter;
 763   4              MAX_DELTA = SUM10 >> 3; //µü´úÍ»±ä(×î´óÆ«²îÖµ)
 764   4              if (MAX_DELTA < MAX_DELTA0)
 765   4                MAX_DELTA = MAX_DELTA0;
 766   4              if (MAX_DELTA > MAX_DELTA1)
 767   4                MAX_DELTA = MAX_DELTA1; //±£Ö¤×î´óÆ«²îÖµÔÚÒ»¶¨·¶Î§ÄÚ
 768   4      
 769   4              if (SUM0 > SUM10)
 770   4              {
 771   5                SUM = SUM0 - SUM10;
 772   5                if (SUM > 80000)
 773   5                  SUM0_num = 6;
 774   5                else if (SUM > 40000)
 775   5                  SUM0_num = 9;
 776   5                else
 777   5                  SUM0_num = 12;
 778   5              }
 779   4              else
 780   4              {
 781   5                SUM0_num = 12;
 782   5              }
 783   4      
 784   4              if ((SUM1_counter >= SUM0_num) && (SUM10 < SUM0))
 785   4              {
 786   5                if (SUM1_num > 16) //???????????????
 787   5                {
 788   6                  if (SUM0_num <= 9)
 789   6                    SUM0 = SUM10;
 790   6                  else if (SUM0 > (SUM10 + 4000))
 791   6                  {
 792   7                    SUM0 += SUM10;
 793   7                    SUM0 /= 2;
 794   7                  }
 795   6                  SUM1_counter = 0;
 796   6                  ALL_SUM1 = 0;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 14  

 797   6                }
 798   5              }
 799   4      
 800   4              else if (SUM1_counter >= SUM1_num)
 801   4              {
 802   5      
 803   5                //              if(SUM0>SUM10)
 804   5                //              {
 805   5                //                if(SUM1_num>16)SUM0=SUM10;  //???????????????
 806   5                //              }
 807   5                //              else
 808   5      
 809   5                if (SUM10 > (SUM0 + 4000))
 810   5                {
 811   6                  SUM = SUM10 - SUM0;
 812   6      
 813   6                  if ((SUM10 < 8000000) && (SUM < 400000))
 814   6                  //????????????,???????????????100000?,???????
 815   6                  {
 816   7                    if (SUM1_num > 16) //????????????
 817   7                    {
 818   8                      SUM0 += SUM10;
 819   8                      SUM0 /= 2;
 820   8                    }
 821   7                    else
 822   7                    {
 823   8                      if (SUM > 300000)
 824   8                        SUM1_num = 16;
 825   8                      else if (SUM > 150000)
 826   8                        SUM1_num = 12;
 827   8                      else
 828   8                        SUM1_num = 8;
 829   8                      if (SUM1_counter >= SUM1_num)
 830   8                      {
 831   9                        SUM0 += SUM10;
 832   9                        SUM0 /= 2;
 833   9                      }
 834   8                    }
 835   7                  }
 836   6                }
 837   5                //              else if((LIGHT>0)&&(TH==TH_LOW))
 838   5                //              {
 839   5                //                SUM=SUM10-SUM0;
 840   5                //                TH+=SUM;    //?????????????
 841   5                //              }
 842   5      
 843   5                if (SUM1_counter >= SUM1_num)
 844   5                {
 845   6                  SUM1_counter = 0;
 846   6                  ALL_SUM1 = 0;
 847   6                }
 848   5              }
 849   4            }
 850   3            else
 851   3            {
 852   4              SUM1_counter = 0;
 853   4              ALL_SUM1 = 0;
 854   4            }
 855   3      
 856   3            if (stop_times > 0) //
 857   3            {
 858   4              stop_times--;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 15  

 859   4              if ((SUM0 > (SUM01 + 6000)) && (SUM1 < (SUM01 + 15000)))
 860   4                SUM0 = SUM01 + 6000;
 861   4            }
 862   3            else
 863   3            {
 864   4      
 865   4              if (start_times > 0)
 866   4              {
 867   5                start_times--;
 868   5      
 869   5                if (start_times > 0) //???????????,???????250*88ms=22S?????????
 870   5                {
 871   6                  //start_times++;
 872   6                  /*
 873   6                    if(SUM0>600000)
 874   6                    {
 875   6                      TH=10000;
 876   6                    }
 877   6                    else */
 878   6                  if (SUM0 > 8000000)
 879   6                  {
 880   7                    TH = 800000;
 881   7                  }
 882   6                  else
 883   6                  {
 884   7                    SUM = SUM0 + TH;
 885   7                    if (SUM > 9000000)
 886   7                    {
 887   8                      TH = 9000000 - SUM0;
 888   8                    }
 889   7                    //if(TH<30000)TH=30000;
 890   7                  }
 891   6                }
 892   5                else
 893   5                {
 894   6                  //TH=TH_LOW;
 895   6                  //start_times=0;
 896   6                  //              EA=0;
 897   6                  //              set_var();
 898   6                  //              EA=1;
 899   6                }
 900   5              }
 901   4      
 902   4              if (SUM1 > (SUM0 + TH))
 903   4              {
 904   5                //SUM=SUM1-SUM0;
 905   5      
 906   5                //  if(SUM>TH)
 907   5                //  {
 908   5                if ((light_ad <= LIGHT_TH) || (start_times > 0))
 909   5                {
 910   6                  //                send_data(0xaa);
 911   6      
 912   6                  //if(alarm_times<2)
 913   6                  //{
 914   6                  //  alarm_times++;
 915   6                  //    }
 916   6                  //if(alarm_times>=2)  //??????????????
 917   6                  {
 918   7                    if (LIGHT == 0)
 919   7                      SUM01 = SUM0;
 920   7                    LIGHT = 1;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 16  

 921   7                    Light_on_flag = 1;
 922   7                    //PC3=0;
 923   7                    //LIGHT_ON;
 924   7                    //slowchcnt = slowchcnt+20;//
 925   7                    //if(slowchcnt>100)
 926   7                    //{
 927   7                    //  slowchcnt = 100;
 928   7                    //}
 929   7                    //PWM3init(slowchcnt);
 930   7                    //P0_6=0;
 931   7                    //                  send_data(0xaa);
 932   7                    //                  send_data((TH/1000)>>8);
 933   7                    //                  send_data((TH/1000)&0xff);
 934   7                    //                  send_data(LIGHT_TH);
 935   7                    //                  send_data(DELAY_NUM>>10);
 936   7                    //                  send_data(DELAY_NUM>>2);    //²âÊÔÓÃ
 937   7                    //                  send_data(slowchcnt);
 938   7                    //                  send_data(0xaa);
 939   7                    send_data(0xdd);
 940   7      
 941   7                    SUM1_num = 8;
 942   7                    LIGHT_off = 0;
 943   7                    light1scount = 0;
 944   7                    light1sflag = 0;
 945   7                    //                send_data(0xaa);
 946   7                  }
 947   6                }
 948   5              }
 949   4            }
 950   3      
 951   3            //SUM2 = SUM1;
 952   3            
 953   3            //send_data(average >> 4);
 954   3            //send_data(light_ad);
 955   3            //send_data(SUM0 >> 16);
 956   3            //send_data(SUM0 >> 8);
 957   3            //send_data(SUM2 >> 16);
 958   3            //send_data(SUM2 >> 8); //20200927  ²âÊÔÓÃ
 959   3      
 960   3            SUM = 0;
 961   3            SUM1 = 0;
 962   3      
 963   3            if (LIGHT > 0) //????
 964   3            {
 965   4      
 966   4              //LIGHT++;
 967   4      
 968   4              //          slowchcnt = slowchcnt+5;//
 969   4              //          if(slowchcnt>=100)
 970   4              //          {
 971   4              //            slowchcnt = 100;
 972   4              //          }
 973   4              //          PWM3init(slowchcnt);
 974   4      
 975   4              if (LIGHT > DELAY_NUM)
 976   4              {
 977   5                LIGHT = 0;
 978   5                while_1flag = 1;
 979   5                Light_on_flag = 0;
 980   5                Light_on_flagpre = 0;
 981   5                //while_2flag = 0;
 982   5                //break;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 17  

 983   5              }
 984   4            }
 985   3          }
 986   2        }
 987   1        else
 988   1        {
 989   2          LIGHT_off = 1;
 990   2          while_1flag = 0;
 991   2          //if(while_2flag==0)
 992   2          //{
 993   2          //  while_2flag = 1;
 994   2          //          send_data(0x55);
 995   2          //}
 996   2          //PC3=1;
 997   2          //LIGHT_OFF;
 998   2          //slowchcnt = lightvalue;
 999   2          //PWM3init(lightvalue);
1000   2          lowlight1mincount = 0;
1001   2          lowlight1minflag = 0;
1002   2      
1003   2          //P0_6=1;
1004   2          //send_data(0x55);
1005   2          Delay_ms(250);
1006   2      
1007   2          //    SUM=0;
1008   2          //    SUM1=0;
1009   2          //    times=0;
1010   2      
1011   2          SUM16 = 0;
1012   2          calc_average_times = 0;
1013   2          SUM1_num = 64;
1014   2      
1015   2          stop_times = 2;
1016   2          //if(start_times==0)TH=TH_LOW;
1017   2          check_light_times = 6;
1018   2      
1019   2          SUM1_counter = 0;
1020   2          ALL_SUM1 = 0;
1021   2      
1022   2          //    send_data(0xdd);
1023   2          //    send_data(0xdd);
1024   2        }
1025   1      }
1026          
1027          void wait1(void)
1028          {
1029   1        u8 i, j;
1030   1      
1031   1        //µÈ´ıÖ±Á÷µçÑ¹ÎÈ¶¨
1032   1        j = 0;
1033   1        while (1)
1034   1        {
1035   2          SUM = 0;
1036   2      
1037   2          //    for(i=0;i<4;i++)  //0.52s
1038   2          //    {
1039   2          //      for(t=0;t<8192;t++) //0.13s
1040   2          //      {
1041   2      
1042   2          //        ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
1043   2          //        while(!(ADCC0&0x20));   //µÈ´ıADC×ª»»½áÊø
1044   2          //        ADCC0 &=~ 0x20;         //Çå³ı±êÖ¾Î»
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 18  

1045   2          //        k = ADCR;       //»ñÈ¡ADCµÄÖµ
1046   2          //
1047   2          //        SUM+=k;
1048   2          //
1049   2          //      }
1050   2          //
1051   2          //      WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1052   2      
1053   2          for (i = 0; i < 128; i++) //
1054   2          {
1055   3      
1056   3            ADCC0 |= 0x40; //Æô¶¯ADC×ª»»
1057   3            while (!(ADCC0 & 0x20))
1058   3              ;     //µÈ´ıADC×ª»»½áÊø
1059   3            ADCC0 &= ~0x20; //Çå³ı±êÖ¾Î»
1060   3            //k = ADCR;       //»ñÈ¡ADCµÄÖµ
1061   3      
1062   3            SUM += ADCR;
1063   3          }
1064   2      
1065   2          //·¢ËÍ¸Ğ¹âADÖµ
1066   2          //        send_byte=0xFA;
1067   2          //        check_sum=send_byte;
1068   2          //        send_data(send_byte);
1069   2      
1070   2          //        //send_byte=light_ad;
1071   2          //        check_sum+=light_ad;
1072   2          //        send_data(light_ad);
1073   2      
1074   2          //        check_sum+=light_ad;
1075   2          //        send_data(light_ad);
1076   2          //
1077   2          //        check_sum+=1;
1078   2          //        send_data(check_sum);
1079   2      
1080   2          //}
1081   2      
1082   2          Delay_ms(400);
1083   2      
1084   2          //WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1085   2      
1086   2          i = SUM >> 11;
1087   2          if ((i > 12) && (i < 141) && (j > 20))
1088   2            break;
1089   2      
1090   2          j++;
1091   2      
1092   2          if (j > 80)
1093   2            break; //??35????????????1.1V???????
1094   2        }
1095   1      }
1096          void wait2(void)
1097          {
1098   1        u8 i;
1099   1        //u8 j;
1100   1        u16 k, t;
1101   1      
1102   1        SUM = 0;
1103   1      
1104   1        for (i = 0; i < 8; i++)
1105   1        {
1106   2          for (t = 0; t < 8192; t++)
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 19  

1107   2          {
1108   3            //        ADC_TG;
1109   3            //        while(ADC_IF==0){};
1110   3            //        //adc_data = ADC_DATA_RD();
1111   3            //
1112   3            //        k = ADC_DH<<8;
1113   3            //        //adc_data =adc_data <<8;
1114   3            //        k+= ADC_DL;
1115   3            //
1116   3            //        ADC_INT_IF_CLR; //ÇåÖĞ¶Ï±êÖ¾Î»
1117   3      
1118   3            ADCC0 |= 0x40; //Æô¶¯ADC×ª»»
1119   3            while (!(ADCC0 & 0x20))
1120   3              ;     //µÈ´ıADC×ª»»½áÊø
1121   3            ADCC0 &= ~0x20; //Çå³ı±êÖ¾Î»
1122   3            k = ADCR;   //»ñÈ¡ADCµÄÖµ
1123   3      
1124   3            SUM += k;
1125   3          }
1126   2          WDTC |= 0x10; //Çå¿´ÃÅ¹·
1127   2        }
1128   1      
1129   1        average = SUM >> 16;
1130   1      
1131   1        //  light_ad=read_ad(10);
1132   1        //  light_ad0=light_ad;
1133   1      
1134   1        //  Delay_ms(4);  //4ms
1135   1      }
1136          
1137          unsigned char PWM3init(unsigned char ab)
1138          {
1139   1        float i11;
1140   1        unsigned char j11;
1141   1        i11 = ab * 255 / 100;
1142   1        j11 = i11;
1143   1      #ifdef V11
                /************************************PWM3³õÊ¼»¯****************************************/
                //P0M3 = P0M3&0xF0|0x08;    //P06ÉèÖÃÎªÍÆÍìÊä³ö
                PWM3_MAP = 0x05; //PWM3Ó³ÉäP05¿Ú
              
              #endif
1149   1      
1150   1      #ifdef V10
                PWM3_MAP = 0x06; //PWM3Ó³ÉäP05¿Ú
              
              #endif
1154   1      
1155   1      #ifdef V12
1156   1        PWM3_MAP = 0x10; //PWM3Ó³ÉäP10¿Ú
1157   1      
1158   1      #endif
1159   1      
1160   1        //ÖÜÆÚ¼ÆËã  = 0xFF / (Fosc / PWM·ÖÆµÏµÊı)   £¨Fosc¼ûÏµÍ³Ê±ÖÓÅäÖÃµÄ²¿·Ö£©
1161   1        //      = 0xFF /(16000000 / 4)
1162   1        //      = 255 /4000000
1163   1        //      = 63.75us   ¼´15.69KHZ
1164   1      
1165   1        PWM3P = 0xFF; //PWMÖÜÆÚÎª0xFF
1166   1        //ÓĞĞ§µçÆ½Ê±¼ä¼ÆËã£¨¼´Õ¼¿Õ±È£©
1167   1        //      = 0x55 / (Fosc / PWM·ÖÆµÏµÊı)   £¨Fosc¼ûÏµÍ³Ê±ÖÓÅäÖÃµÄ²¿·Ö£©
1168   1        //      = 0x55 /(16000000 / 4)
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 20  

1169   1        //      = 85 /4000000
1170   1        //      = 21.25us   Õ¼¿Õ±ÈÎª 21.25 / 63.75 = 34%
1171   1      
1172   1        PWM3D = j11;  //PWMÕ¼¿Õ±ÈÉèÖÃ
1173   1        PWM3C = 0x94; //Ê¹ÄÜPWM3£¬¹Ø±ÕÖĞ¶Ï£¬ÔÊĞíÊä³ö£¬Ê±ÖÓ16·ÖÆµ
1174   1      
1175   1        return 0;
1176   1      }
1177          
1178          void reset_bt_module(void);
1179          
1180          /***************************************************************************************
1181            * @ËµÃ÷   Ö÷º¯Êı
1182            * @²ÎÊı   ÎŞ
1183            * @·µ»ØÖµ ÎŞ
1184            * @×¢     ÎŞ
1185          ***************************************************************************************/
1186          void main()
1187          {
1188   1      //  u8 i;
1189   1        wifi_protocol_init(); //mcu_sdk
1190   1        InitSYS();
1191   1        GPIO_Init();
1192   1        //LIGHT_ON;
1193   1        //P0_6=0;
1194   1        PWM3init(100);
1195   1        Timer_Init();
1196   1        UART1_Init();
1197   1        ADC_Init();
1198   1      
1199   1        LVDC = 0xAA; //LVDÉèÖÃ2.4V,½ûÖ¹ÖĞ¶Ï
1200   1        //  Ïû¶¶Ê±¼ä =  (0xFF + 2) * 1/Fcpu
1201   1        //       =  (0xFF + 2) / 16000000 £¨µ±Ç°µÄCPUÊ±ÖÓ£©
1202   1        //       =  16.0625us
1203   1        LVDDBC = 0xFF; //ÉèÖÃÏû¶¶Ê±¼ä
1204   1        LVDC &= ~0x08; //Çå³ıLVDÖĞ¶Ï±êÖ¾Î»
1205   1                 //
1206   1        EA = 1;
1207   1      
1208   1        Delay_ms(200);
1209   1      
1210   1        //LIGHT_ON;
1211   1        PWM3init(100);
1212   1        SWITCHflag = 1;
1213   1        light_ad = read_ad(10);
1214   1        light_ad0 = light_ad;
1215   1      
1216   1        EA = 0;
1217   1        set_var(); //´Óflash¶ÁÈ¡³ö±äÁ¿
1218   1      
1219   1        //for(i=0;i<5;i++)send_data(guc_Read_a[i]);
1220   1      
1221   1        //  TXdata[0]=VERSION;
1222   1        //  t=TH/1000;
1223   1        //  TXdata[1]=t>>8;
1224   1        //  TXdata[2]=t;
1225   1        //  TXdata[3]=LIGHT_TH;
1226   1        //  t=DELAY_NUM/4;
1227   1        //  TXdata[4]=t>>8;
1228   1        //  TXdata[5]=t;
1229   1      
1230   1        //  TXdata[6]=light_ad;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 21  

1231   1      
1232   1        //  for(i=0;i<7;i++)send_data(TXdata[i]);
1233   1        resetbtcnt++;
1234   1      
1235   1        Flash_EraseBlock(0x2F80);
1236   1        Delay_us_1(10000);
1237   1        FLASH_WriteData(resetbtcnt, 0x2F80);
1238   1        Delay_us_1(100);
1239   1      
1240   1        EA = 1;
1241   1      
1242   1        wait1();
1243   1      
1244   1        slowchcnt = lightvalue;
1245   1        //Delay_ms(200);
1246   1        PWM3init(lightvalue);
1247   1        //LIGHT_OFF;
1248   1        //P0_6=1;
1249   1        Delay_ms(300);
1250   1      
1251   1        wait2();
1252   1      
1253   1        SUM = 0;
1254   1        while (1)
1255   1        {
1256   2          if (resetbtcnt >= 3)  //ĞĞÎªÊÇÃ¿Èı´ÎÉÏµç»á¸´Î»Ò»´ÎÀ¶ÑÀÄ£¿é
1257   2          {
1258   3            resetbtcnt = 0;
1259   3            reset_bt_module();
1260   3          }
1261   2      
1262   2          if (check_group_count <= 2) //Ò»ÉÏµç¼ä¸ôÒ»Ãë»ñÈ¡3´ÎÈº×éµØÖ·
1263   2          {
1264   3            if (check_group_flag == 1)
1265   3            {
1266   4              check_group_flag = 0;
1267   4              check_group_count++;
1268   4      
1269   4              send_data(0x55);
1270   4              send_data(0xAA);
1271   4              send_data(0X00);
1272   4              send_data(0XB4); //ĞÂµÄÃüÁî×Ö£¬¹¦ÄÜ²»Ã÷
1273   4              send_data(0X00);
1274   4              send_data(0X00);
1275   4              send_data(0Xb3);
1276   4            }
1277   3          }
1278   2          WDTC |= 0x10; //Çå¿´ÃÅ¹·
1279   2      
1280   2          if (while_1flag == 0)
1281   2          {
1282   3            if ((times & 0x1f) == 0)
1283   3              wifi_uart_service();
1284   3          }
1285   2      
1286   2          if (SWITCHfXBR == 1) //À×´ï¿ª, app¿ØÖÆ
1287   2          {
1288   3            if (while_2flag == 0)
1289   3            {
1290   4              while_1flag = 0;
1291   4      
1292   4              while_2flag = 1;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 22  

1293   4              slowchcnt = lightvalue;
1294   4      
1295   4              SUM16 = 0;
1296   4              calc_average_times = 0;
1297   4              SUM1_num = 64;
1298   4      
1299   4              stop_times = 2;
1300   4              //if(start_times==0)TH=TH_LOW;
1301   4              check_light_times = 6;
1302   4      
1303   4              SUM1_counter = 0;
1304   4              ALL_SUM1 = 0;
1305   4            }
1306   3      
1307   3            XBRHandle();
1308   3      
1309   3            if (LIGHT_off > 0) //¹ØµÆÑÓÊ±
1310   3            {
1311   4              if (lowlight1minflag == 1)
1312   4              {
1313   5                lowlight1minflag = 0;
1314   5                LIGHT_off++;
1315   5                if (LIGHT_off >= lowlightDELAY_NUM)
1316   5                {
1317   6                  LIGHT_off = 0;
1318   6                  PWM3init(0);
1319   6                }
1320   5              }
1321   4            }
1322   3            if (LIGHT > 0) //ÁÁµÆÑÓÊ±
1323   3            {
1324   4              if (light1sflag == 1)
1325   4              {
1326   5                light1sflag = 0;
1327   5                LIGHT++;
1328   5                //slowchcnt = slowchcnt+20;//
1329   5                //          if(slowchcnt>100)
1330   5                //          {
1331   5                //            slowchcnt = 100;
1332   5                //          }
1333   5                //          PWM3init(slowchcnt);
1334   5              }
1335   4            }
1336   3      
1337   3            //Áª¶¯
1338   3            if (Linkage_flag == 1)
1339   3            {
1340   4      //        if (Light_on_flagpre != Light_on_flag)
1341   4      //        {
1342   4      //          Light_on_flagpre = Light_on_flag;
1343   4      //          LIGHT = 1;
1344   4      //          //PWM3init(100);
1345   4      //          for (i = 0; i < 8; i++)
1346   4      //          {
1347   4      //            if (groupaddr[i] != 0)
1348   4      //            {
1349   4      //              mcu_dp_bool_mesh_update(DPID_SWITCH_LED2, SWITCHflag2, groupaddr[i]);
1350   4      //            }
1351   4      //          }
1352   4      //        }
1353   4            }
1354   3          }
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 23  

1355   2          else
1356   2          { //À×´ï¹Ø
1357   3            while_2flag = 0;
1358   3            if (SWITCHflag2 == 0) //¹ØµÆ
1359   3            {
1360   4              PWM3init(0);
1361   4            }
1362   3            else
1363   3            { //¿ªµÆ
1364   4              PWM3init(XRBoffbrightvalue);
1365   4      
1366   4              while_1flag = 0;
1367   4      
1368   4              slowchcnt = lightvalue;
1369   4              //PWM3init(lightvalue);
1370   4      
1371   4              SUM16 = 0;
1372   4              calc_average_times = 0;
1373   4              SUM1_num = 64;
1374   4      
1375   4              stop_times = 2;
1376   4              //if(start_times==0)TH=TH_LOW;
1377   4              check_light_times = 6;
1378   4      
1379   4              SUM1_counter = 0;
1380   4              ALL_SUM1 = 0;
1381   4            }
1382   3          }
1383   2        }
1384   1      
1385   1        //  while(1)
1386   1        //  {
1387   1        //    System_Time_Cnt();
1388   1        //    System_Task();
1389   1        //    WDTC |= 0x10;              //Çå¹·
1390   1        //  }
1391   1      }
1392          
1393          /***************************************************************************************
1394            * @ËµÃ÷   T1ÖĞ¶Ï·şÎñº¯Êı
1395            * @²ÎÊı   ÎŞ
1396            * @·µ»ØÖµ ÎŞ
1397            * @×¢     ÎŞ
1398          ***************************************************************************************/
1399          void TIMER1_Rpt(void) interrupt TIMER1_VECTOR
1400          {
1401   1        //Timer1_FLAG = 1;    //1mS
1402   1        Timer_Counter++;
1403   1      
1404   1        lowlight1mincount++;
1405   1        if (lowlight1mincount >= 60000)
1406   1        {
1407   2          lowlight1mincount = 0;
1408   2          lowlight1minflag = 1;
1409   2        }
1410   1        light1scount++;
1411   1        if (light1scount >= 1000)
1412   1        {
1413   2          check_group_flag = 1;
1414   2          light1scount = 0;
1415   2          light1sflag = 1;
1416   2        }
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 24  

1417   1      }
1418          
1419          /***************************************************************************************
1420            * @ËµÃ÷   UART1ÖĞ¶Ï·şÎñº¯Êı
1421            * @²ÎÊı   ÎŞ
1422            * @·µ»ØÖµ ÎŞ
1423            * @×¢     ÎŞ
1424          ***************************************************************************************/
1425          
1426          void UART1_Rpt(void) interrupt UART1_VECTOR
1427          {
1428   1        u8 i;
1429   1        //u16 t;
1430   1      
1431   1        if (SCON & 0x01) //ÅĞ¶Ï½ÓÊÕÖĞ¶Ï±êÖ¾Î»
1432   1        {
1433   2          i = SBUF;
1434   2          uart_receive_input(i); //mcu_sdk
1435   2          SCON &= ~0x01;       //Çå³ı½ÓÊÕÖĞ¶Ï±êÖ¾Î»
1436   2          EA = 1;
1437   2        }
1438   1      }
1439          
1440          void UART2_Rpt(void) interrupt UART2_VECTOR
1441          {
1442   1      }
1443          
1444          // void Delay_2us(u16 Cnt)
1445          // {
1446          //  while(Cnt--);
1447          // }
1448          
1449          void Flash_EraseBlock(unsigned int fui_Address)
1450          {
1451   1        while (1)
1452   1        {
1453   2          LVDC &= ~0x08; //Çå³ıLVDÖĞ¶Ï±êÖ¾Î»
1454   2          P0_0 = 0;
1455   2          if ((LVDC & 0x08) == 0)
1456   2            break;
1457   2        }
1458   1        P0_0 = 1;
1459   1        EA = 0;
1460   1        IAP_CMD = 0xF00F;   //Flash½âËø
1461   1        IAP_ADDR = fui_Address; //Ğ´Èë²Á³ıµØÖ·
1462   1        IAP_CMD = 0xD22D;   //Ñ¡Ôñ²Ù×÷·½Ê½£¬ ÉÈÇø²Á³ı
1463   1        IAP_CMD = 0xE11E;   //´¥·¢ºóIAP_ADDRL&IAP_ADDRHÖ¸Ïò0xFF£¬Í¬Ê±×Ô¶¯Ëø¶¨
1464   1                    //EA=1;
1465   1      }
1466          
1467          /**
1468            * @ËµÃ÷   Ğ´ÈëÒ»¸ö×Ö½ÚÊı¾İµ½FlashÀïÃæ
1469            *         ¸Ãº¯ÊıĞè¾ø¶ÔµØÖ·±àÒë£¬ÏêÇéÇë²éÔÄIAP²Ù×÷Ó¦ÓÃÊÖ²á
1470            * @²ÎÊı   fui_Address £ºFLASHµØÖ·
1471            * @²ÎÊı   fucp_SaveData£ºĞ´ÈëµÄÊı¾İ
1472            * @·µ»ØÖµ ÎŞ
1473            * @×¢     Ğ´Ö®Ç°±ØĞëÏÈ¶Ô²Ù×÷µÄÉÈÇø½øĞĞ²Á³ı
1474            */
1475          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address)
1476          {
1477   1        while (1)
1478   1        {
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/21/2020 10:49:09 PAGE 25  

1479   2          LVDC &= ~0x08; //Çå³ıLVDÖĞ¶Ï±êÖ¾Î»
1480   2          P0_0 = 0;
1481   2          if ((LVDC & 0x08) == 0)
1482   2            break;
1483   2        }
1484   1        P0_0 = 1;
1485   1        EA = 0;
1486   1        IAP_DATA = fuc_SaveData;
1487   1        IAP_CMD = 0xF00F; //Flash½âËø
1488   1        IAP_ADDR = fui_Address;
1489   1        IAP_CMD = 0xB44B; //×Ö½Ú±à³Ì
1490   1        IAP_CMD = 0xE11E; //´¥·¢Ò»´Î²Ù×÷
1491   1                  //EA=1;
1492   1      }
1493          
1494          /**
1495            * @ËµÃ÷   Ğ´ÈëÈÎÒâ³¤¶ÈµÄÊı¾İµ½FLASHÀïÃæ
1496            *         ¸Ãº¯ÊıĞè¾ø¶ÔµØÖ·±àÒë£¬ÏêÇéÇë²éÔÄIAP²Ù×÷Ó¦ÓÃÊÖ²á
1497            * @²ÎÊı   fui_Address £ºFLASHÆğÊ¼µØÖ·
1498            * @²ÎÊı   fuc_Length £º Ğ´ÈëÊı¾İ³¤¶È
1499            *         È¡Öµ·¶Î§£º0x00-0xFF
1500            * @²ÎÊı  *fucp_SaveArr£ºĞ´ÈëµÄÊı¾İ´æ·ÅÇøÓòµÄÊ×µØÖ·
1501            * @·µ»ØÖµ ÎŞ
1502            * @×¢     Ğ´Ö®Ç°±ØĞëÏÈ¶Ô²Ù×÷µÄÉÈÇø½øĞĞ²Á³ı
1503            */
1504          
1505          // void Flash_WriteArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr)
1506          // {
1507          //  unsigned char fui_i = 0;
1508          //  EA=0;
1509          //  for(fui_i=0;fui_i<fuc_Length;fui_i++)
1510          //  {
1511          //    FLASH_WriteData(*(fucp_SaveArr++), fui_Address++);
1512          //  }
1513          //  EA=1;
1514          // }
1515          
1516          /**
1517            * @ËµÃ÷   ´ÓFLASHÀïÃæ¶ÁÈ¡ÈÎÒâ³¤¶ÈµÄÊı¾İ
1518            * @²ÎÊı   fui_Address £ºFLASHÆğÊ¼µØÖ·
1519            * @²ÎÊı   fuc_Length £º¶ÁÈ¡Êı¾İ³¤¶È
1520            *         È¡Öµ·¶Î§£º0x00-0xFF
1521            * @²ÎÊı  *fucp_SaveArr£º¶ÁÈ¡Êı¾İ´æ·ÅµÄÇøÓòÊ×µØÖ·
1522            * @·µ»ØÖµ ÎŞ
1523            * @×¢     ÎŞ
1524            */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3474    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     87    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      14
   IDATA SIZE       =     25    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
